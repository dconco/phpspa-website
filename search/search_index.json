{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"PhpSPA        \ud83d\udc4b <p>     Ready to build modern, reactive web UIs without leaving the comfort of PHP? You're in the right place. </p> <p>What is PhpSPA?</p> <p>PhpSPA is a component-based library that brings the power and syntax of React to your PHP workflow. You build small, reusable components, and the library handles the magic of rendering them and updating the UI when their state changes.</p> <p>\u26a1 Built for Performance</p> <ul> <li>Virtual DOM Diffing (morphdom) - Only updates what changed</li> <li>View Transitions API - Smooth, native browser animations  </li> <li>Native C++ Compression - Ultra-fast HTML minification via FFI</li> <li>Lightweight - Built for speed from the ground up, zero dependencies</li> </ul> <p> </p>"},{"location":"#quick-start","title":"Quick Start","text":"<ul> <li> <p> Installation</p> <p>Get started with PhpSPA in seconds using Composer</p> <p> Install Now</p> </li> <li> <p> Core Concepts</p> <p>Learn the fundamentals of App and Component</p> <p> Learn Basics</p> </li> <li> <p> Routing</p> <p>Master dynamic routing and navigation</p> <p> Explore Routing</p> </li> <li> <p> State Management</p> <p>Build reactive UIs with useState and useEffect</p> <p> Manage State</p> </li> </ul>"},{"location":"#key-features","title":"Key Features","text":"Component-BasedReactive StateClient-Side RoutingPHP Functions from JS <p>Build your UI with small, reusable components just like React</p> <pre><code>&lt;?php\n\nfunction Button() {\n    return &lt;&lt;&lt;HTML\n        &lt;button&gt;Click Me&lt;/button&gt;\n    HTML;\n}\n</code></pre> <p>Components automatically re-render when state changes</p> <pre><code>&lt;?php\n\nuse function Component\\useState;\n\n$count = useState('count', 0);\n\necho  &lt;&lt;&lt;HTML\n    &lt;button onclick=\"setState('count', {$count} + 1)\"&gt;\n        Count: {$count}\n    &lt;/button&gt;\nHTML;\n</code></pre> <p>Navigate between pages without full page reloads</p> <pre><code>&lt;Component.Link to=\"/about\"&gt;About&lt;/Component.Link&gt;\n</code></pre> <p>Call PHP functions directly from JavaScript without APIs</p> <pre><code>&lt;?php\n\nuse function Component\\useFunction;\n\n$greeter = useFunction(fn($name) =&gt; \"Hello, $name!\");\n\n  const greeting = await {$greeter('name')};\n</code></pre> <p>Documentation Overview</p> <p>This documentation is designed to be fast and straight to the point. No long stories, just code. Let's dive in and start building something awesome. \ud83d\ude80</p>"},{"location":"core-concepts/","title":"Core Concepts: App &amp; Component","text":"<p> Everything in PhpSPA revolves around two main classes: <code>App</code> and <code>Component</code>. </p> <ul> <li> <p> App</p> <p>This is the main container for your entire application. It holds your layout and manages all your components.</p> </li> <li> <p> Component</p> <p>This is a reusable piece of your UI. Think of it as a simple PHP function that outputs HTML.</p> </li> </ul> <p>Simple Workflow</p> <p>You create one <code>App</code> instance, create your <code>Component</code>s, and then attach them to the app.</p> <p>Required Namespaces</p> <p>All PhpSPA applications require these namespace imports: <pre><code>&lt;?php\nuse PhpSPA\\App;\nuse PhpSPA\\Component;\n</code></pre> Include these at the top of your PHP files.</p>"},{"location":"core-concepts/#heres-how-they-work-together","title":"Here's how they work together:","text":"<p>1. Define a Layout</p> <pre><code>&lt;?php\n\n$Layout = function () {\n   return '&lt;div id=\"app\"&gt;&lt;/div&gt;';\n};\n</code></pre> <p>The layout defines where components will render.</p> <p>2. Create the App</p> <pre><code>&lt;?php\n\n$app = new App($Layout);\n</code></pre> <p>Initialize the main application with your layout.</p> <p>3. Build a Component</p> <pre><code>&lt;?php\n\n$homePage = new Component(function () {\n   return \"&lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;\";\n});\n</code></pre> <p>Components are functions that return HTML.</p> <p>4. Set the Route</p> <pre><code>&lt;?php\n\n$homePage-&gt;route('/');\n</code></pre> <p>Configure which URL path triggers this component.</p> <p>5. Attach to App</p> <pre><code>&lt;?php\n\n$app-&gt;attach($homePage);\n</code></pre> <p>Register the component with the application.</p> <p>6. Run the Application</p> <pre><code>&lt;?php\n\n$app-&gt;run();\n</code></pre> <p>Render the page.</p>"},{"location":"core-concepts/#complete-example","title":"Complete Example","text":"<pre><code>&lt;?php\n\nuse PhpSPA\\App;\nuse PhpSPA\\Component;\n\n$Layout = function () {\n   return '&lt;div id=\"app\"&gt;&lt;/div&gt;';\n};\n\n$app = new App($Layout);\n\n$homePage = new Component(function () {\n   return \"&lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;\";\n});\n\n$homePage-&gt;route('/');\n$app-&gt;attach($homePage);\n$app-&gt;run();\n</code></pre>"},{"location":"installation/","title":"\ud83d\ude80 Installation","text":"<p> Getting PhpSPA up and running is simple. You have two options: use our pre-configured template for a new project, or install the library into an existing one. </p>"},{"location":"installation/#using-the-template-recommended","title":"Using the Template (Recommended)","text":"<p>Quick Setup</p> <p>This is the quickest way to start a new project. It sets up the entire project structure for you.</p> <p>Step 1: Create the Project</p> <p>Run the following command to clone the template into a new directory.</p> <pre><code>composer create-project phpspa/phpspa my-app\n</code></pre> <p>Step 2: Navigate to Your Project</p> <pre><code>cd my-app\n</code></pre> <p>Step 3: Start the Development Server</p> <p>The template comes with a built-in PHP development server.</p> <pre><code>composer start\n</code></pre> <p>That's it!</p> <p>Your PhpSPA application is now running and ready for you to start building. \u2728</p>"},{"location":"installation/#starting-from-scratch","title":"Starting From Scratch","text":"<p>Existing Projects</p> <p>If you want to integrate PhpSPA into an existing project, you can install it directly with Composer.</p> <pre><code>composer require dconco/phpspa\n</code></pre> <p>Additional Setup Required</p> <p>You will then need to set up your own layout and <code>index.php</code> file to initialize the <code>App</code> class.</p>"},{"location":"layout/","title":"The Layout","text":"<p> Your Layout is the main HTML shell that wraps your entire application. It's where you define your <code>&lt;html&gt;</code> document, the <code>&lt;head&gt;</code> section, and any global scripts or styles. </p> <p>Simple Rule</p> <p>A layout has a simple rule:</p> <p>Provide a target element. This is where your components will be rendered. A common &amp; default choice is <code>&lt;div id=\"app\"&gt;&lt;/div&gt;</code>.</p>"},{"location":"layout/#example-layout-layoutphp","title":"Example Layout (<code>/layout.php</code>)","text":"<p>Layout Structure</p> <p>This file simply returns a function that outputs your HTML structure.</p> <pre><code>&lt;?php\n\nreturn fn () =&gt; &lt;&lt;&lt;HTML\n   &lt;!DOCTYPE html&gt;\n   &lt;html&gt;\n      &lt;head&gt;\n         &lt;title&gt;My Awesome App&lt;/title&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n         &lt;div id=\"app\"&gt;&lt;/div&gt;\n      &lt;/body&gt;\n   &lt;/html&gt;\nHTML;\n</code></pre>"},{"location":"layout/#using-the-layout","title":"Using the Layout","text":"<p>You then pass this layout directly to your <code>App</code> when you create it.</p> <pre><code>&lt;?php\n\nuse PhpSPA\\App;\n\n// Load the layout file\n$layout = require __DIR__ . '/layout.php';\n\n// Initialize the app with the layout\n$app = new App($layout);\n</code></pre> <p>Result</p> <p>Now, all components attached to your app will be rendered inside that <code>&lt;div id=\"app\"&gt;&lt;/div&gt;</code>.</p>"},{"location":"layout/#setting-the-default-target-id","title":"Setting the Default Target ID","text":"<p>By default, PhpSPA looks for an element with the ID <code>app</code> to render components. However, you can change this to any ID you prefer using the <code>defaultTargetID()</code> method.</p> <pre><code>&lt;?php\n\nuse PhpSPA\\App;\n\n$layout = require __DIR__ . '/layout.php';\n$app = new App($layout);\n\n// Set the default target ID for all components\n$app-&gt;defaultTargetID('app'); // This is the default\n\n// Or use a custom ID\n$app-&gt;defaultTargetID('main-content');\n</code></pre> <p>Custom Target Element</p> <p>If your layout uses a different ID like <code>&lt;div id=\"main-content\"&gt;&lt;/div&gt;</code>, make sure to set it with <code>defaultTargetID()</code>.</p>"},{"location":"layout/#example-with-custom-target","title":"Example with Custom Target","text":"<pre><code>&lt;?php\n// Layout file with custom ID\nreturn fn () =&gt; &lt;&lt;&lt;HTML\n   &lt;!DOCTYPE html&gt;\n   &lt;html&gt;\n      &lt;head&gt;\n         &lt;title&gt;My App&lt;/title&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n         &lt;header&gt;Site Header&lt;/header&gt;\n         &lt;div id=\"main-content\"&gt;&lt;/div&gt;\n         &lt;footer&gt;Site Footer&lt;/footer&gt;\n      &lt;/body&gt;\n   &lt;/html&gt;\nHTML;\n</code></pre> <pre><code>&lt;?php\n// index.php\nuse PhpSPA\\App;\n\n$layout = require __DIR__ . '/layout.php';\n$app = new App($layout);\n\n// Tell PhpSPA to render components inside #main-content\n$app-&gt;defaultTargetID('main-content');\n\n// ... attach components and run\n$app-&gt;run();\n</code></pre> <p>Flexible Layouts</p> <p>This allows you to create complex layouts with headers, sidebars, and footers, while controlling exactly where your dynamic content renders.</p>"},{"location":"components/","title":"The Power of Components","text":"<p> The core of PhpSPA is its component-based architecture. A component is a reusable piece of your UI, defined as a simple PHP function that returns an HTML string. </p> <p>The Magic</p> <p>The magic happens when you use these components like HTML tags inside the <code>heredoc</code> string of another component. This allows you to build complex pages by nesting smaller, reusable parts.</p>"},{"location":"components/#functional-components","title":"Functional Components","text":"<p>Simple Component</p> <p>First, define a simple component.</p> <pre><code>&lt;?php\n// A simple, reusable button component\nfunction Button() {\n   return &lt;&lt;&lt;HTML\n     &lt;button&gt;Click Me&lt;/button&gt;\n   HTML;\n}\n</code></pre> <p>Now, use that <code>Button</code> component inside a main page component.</p> <pre><code>&lt;?php\nfunction HomePage() {\n   return &lt;&lt;&lt;HTML\n      &lt;div class=\"container\"&gt;\n         &lt;h1&gt;Welcome!&lt;/h1&gt;\n         &lt;p&gt;Click the button below to continue.&lt;/p&gt;\n\n         &lt;Button /&gt;\n      &lt;/div&gt;\n   HTML;\n}\n</code></pre>"},{"location":"components/#handling-children-and-props","title":"Handling Children and Props","text":"<p>True Power</p> <p>Components become truly powerful when you pass data to them as props (attributes) and children (content inside the tags).</p> Example Components with PropsComposing Them in a Page <pre><code>&lt;?php\nuse function Component\\HTMLAttrInArrayToString;\n\n// Accepts children\nfunction Card($children) {\n   return &lt;&lt;&lt;HTML\n      &lt;div class=\"card\"&gt;\n         {$children}\n      &lt;/div&gt;\n   HTML;\n}\n\n// Accepts props and children\nfunction LinkButton($to, $children, ...$attributes) {\n   // Convert any extra HTML attributes into a string\n   $attrString = HTMLAttrInArrayToString($attributes);\n\n   return &lt;&lt;&lt;HTML\n     &lt;a href=\"{$to}\" {$attrString}&gt;\n       {$children}\n     &lt;/a&gt;\n   HTML;\n}\n</code></pre> <p>Now, let's use these components inside a <code>UserProfile</code> component. This shows how everything nests together.</p> <pre><code>&lt;?php\nfunction UserProfile() {\n   return &lt;&lt;&lt;HTML\n      &lt;Card&gt;\n         &lt;h2&gt;User Dashboard&lt;/h2&gt;\n         &lt;p&gt;Welcome back! Here are your options:&lt;/p&gt;\n\n         &lt;LinkButton to=\"/settings\" class=\"btn btn-primary\"&gt;\n            Edit Settings\n         &lt;/LinkButton&gt;\n\n         &lt;LinkButton to=\"/logout\" class=\"btn btn-secondary\"&gt;\n            Log Out\n         &lt;/LinkButton&gt;\n      &lt;/Card&gt;\n   HTML;\n}\n</code></pre> <p>Key Takeaway</p> <p>You build your entire UI by composing these components. As long as the final output is one component attached to the <code>App</code> class, <code>PhpSPA</code> will handle rendering the entire nested tree.</p>"},{"location":"components/advanced-component/","title":"Advanced Component Patterns","text":"<p> Beyond simple functions, PhpSPA offers several powerful ways to structure and call your components, giving you flexibility for any project architecture. </p>"},{"location":"components/advanced-component/#class-based-components","title":"Class-Based Components","text":"<p>Complex Components</p> <p>For more complex components that might have their own methods or properties, you can use a class. If a class has a <code>__render()</code> method, <code>PhpSPA</code> will automatically call it when the class is used as a component. Props and children are passed as arguments to the <code>__render</code> method.</p> <pre><code>&lt;?php\nclass Alert {\n   // This method is called automatically\n   public function __render($type, $children) {\n      $class = \"alert alert-{$type}\"; // e.g., 'alert alert-success'\n\n      return &lt;&lt;&lt;HTML\n         &lt;div class=\"{$class}\"&gt;\n            {$children}\n         &lt;/div&gt;\n      HTML;\n   }\n}\n\n// How to use it:\nfunction StatusMessage() {\n   return &lt;&lt;&lt;HTML\n      &lt;Alert type=\"success\"&gt;\n         &lt;strong&gt;Success!&lt;/strong&gt; Your profile has been updated.\n      &lt;/Alert&gt;\n   HTML;\n}\n</code></pre> <p>Method Components</p> <p>You can even call other public methods of a class directly as components using the <code>::</code> syntax.</p> <pre><code>&lt;MyComponent::Header /&gt;\n&lt;MyComponent::Footer /&gt;\n</code></pre>"},{"location":"components/advanced-component/#namespaced-and-variable-components","title":"Namespaced and Variable Components","text":"<p>Flexible Organization</p> <p>PhpSPA makes it easy to organize and use components from different parts of your codebase.</p> Namespaced ComponentsCallable Variable Components <p>If your component function is in a namespace, use a dot (<code>.</code>) instead of a backslash (<code>\\</code>) to call it.</p> <pre><code>&lt;?php\n// Assuming Button is in the UI\\Elements namespace\nfunction SomePage() {\n   return &lt;&lt;&lt;HTML\n      &lt;UI.Elements.Button /&gt;\n   HTML;\n}\n</code></pre> <p>You can assign a component to a variable and use it directly. This is great for dynamic components or for keeping your template logic clean. To use a variable component, prefix its name with <code>@</code> or <code>$</code> (if using <code>$</code>, escape it within <code>heredoc</code> strings: <code>&lt;\\$Link /&gt;</code>).</p> <pre><code>&lt;?php\nfunction Navigation() {\n   // Define a component as a callable variable\n   $NavLink = fn ($to, $children) =&gt; &lt;&lt;&lt;HTML\n      &lt;a href=\"{$to}\" class=\"nav-link\"&gt;{$children}&lt;/a&gt;\n   HTML;\n\n   // Export the variable to make it available in the heredoc scope\n   scope(compact('NavLink'));\n\n   // Use the variable component with the @ prefix\n   return &lt;&lt;&lt;HTML\n      &lt;nav&gt;\n         &lt;@NavLink to=\"/\"&gt;Home&lt;/@NavLink&gt;\n         &lt;@NavLink to=\"/about\"&gt;About&lt;/@NavLink&gt;\n\n         &lt;!-- Or using the $ prefix (escaped) --&gt;\n         &lt;\\$NavLink to=\"/contact\"&gt;Contact&lt;/\\$NavLink&gt;\n      &lt;/nav&gt;\n   HTML;\n}\n</code></pre>"},{"location":"hooks/updating-state-of-mapped-arrays/","title":"Updating State of Mapped Arrays","text":"<p>State becomes truly useful when you modify it based on user actions, like clicking a button. This is done using the client-side <code>setState()</code> function.</p> <p>Two Approaches</p> <p>You can update state in two primary ways: a quick inline method for simple changes, and a more robust script-based method for complex logic.</p>"},{"location":"hooks/updating-state-of-mapped-arrays/#the-direct-way-inline-updates","title":"The Direct Way: Inline Updates","text":"<p>For simple actions like adding a new item to a list, you can call <code>setState()</code> directly within an HTML attribute like <code>onclick</code>.</p> <p>This approach uses the JavaScript spread syntax (<code>...</code>) to create a new array that includes all the old items plus the new one.</p> <pre><code>&lt;?php\nuse function Component\\useState;\n\nfunction TodoList() {\n   $todos = useState('todos', [\n      ['id' =&gt; 1, 'text' =&gt; 'Learn phpspa'],\n   ]);\n\n   $newId = count($todos()) + 1;\n\n   return &lt;&lt;&lt;HTML\n      &lt;div&gt;\n         &lt;h3&gt;My To-Do List&lt;/h3&gt;\n         &lt;ul&gt;\n            {$todos-&gt;map(fn($item) =&gt; \"&lt;li&gt;{$item['text']}&lt;/li&gt;\")}\n         &lt;/ul&gt;\n\n         &lt;button onclick='setState(\"todos\", [...{$todos}, { id: {$newId}, text: \"A new task\" }])'&gt;\n            Add Todo\n         &lt;/button&gt;\n      &lt;/div&gt;\n   HTML;\n}\n</code></pre> <p>Spread Syntax</p> <p>This approach uses the JavaScript spread syntax (<code>...</code>) to create a new array that includes all the old items plus the new one.</p>"},{"location":"hooks/updating-state-of-mapped-arrays/#the-customizable-way-using-a-script","title":"The Customizable Way: Using a Script","text":"<p>When your update logic is more complex (e.g., reading from input fields), it's cleaner to use a dedicated JavaScript function.</p> <p>First, pass your initial state to a JavaScript variable. Then, you can manipulate this variable with standard JavaScript before calling <code>setState()</code> with the final data.</p> <pre><code>&lt;?php\nuse function Component\\useState;\n\nfunction TodoList() {\n   $todos = useState('todos', [\n      ['id' =&gt; 1, 'text' =&gt; 'Learn phpspa'],\n   ]);\n\n   return &lt;&lt;&lt;HTML\n      &lt;div&gt;\n         &lt;h3&gt;My To-Do List&lt;/h3&gt;\n         &lt;ul id=\"todo-list-ul\"&gt;\n            {$todos-&gt;map(fn($item) =&gt; \"&lt;li&gt;{$item['text']}&lt;/li&gt;\")}\n         &lt;/ul&gt;\n\n         &lt;button onclick=\"addTodo()\"&gt;Add Todo&lt;/button&gt;\n      &lt;/div&gt;\n\n      &lt;script&gt;\n         // Get the initial state from PHP\n         let todosData = {$todos};\n\n         function addTodo() {\n            // Perform any logic you need in JavaScript\n            let newId = todosData.length + 1;\n            todosData.push({ id: newId, text: 'New task ' + newId });\n\n            // Update the state with the modified array\n            setState('todos', todosData);\n         }\n      &lt;/script&gt;\n   HTML;\n}\n</code></pre> <p>Complex Logic</p> <p>First, pass your initial state to a JavaScript variable. Then, you can manipulate this variable with standard JavaScript before calling <code>setState()</code> with the final data.</p>"},{"location":"hooks/use-effect/","title":"Handling Side Effects with <code>useEffect</code>","text":"<p>Sometimes you need to perform actions after your component has rendered, like fetching data from an API, logging to the console, or manually manipulating the DOM. These actions are called \"side effects,\" and the <code>useEffect</code> hook is the perfect tool for managing them.</p> <p>Effect Hook</p> <p>The hook takes two arguments: a callback function to run and an array of dependencies to watch.</p>"},{"location":"hooks/use-effect/#basic-usage-watching-for-changes","title":"Basic Usage: Watching for Changes","text":"<p>The most common use case is to run code whenever a specific piece of state changes.</p> <pre><code>&lt;?php\n\nuse function Component\\useState;\nuse function Component\\useEffect;\n\nfunction Counter() {\n   $count = useState('count', 0);\n   $script = '';\n\n   // This effect will run every time the 'count' state changes.\n   useEffect(function ($count) use (&amp;$script) {\n      // This script runs on the client-side after the re-render.\n       $script = \"&lt;script&gt;console.log('The counter is now: {$count}')&lt;/script&gt;\";\n   }, [$count]);\n\n   return &lt;&lt;&lt;HTML\n      &lt;h2&gt;Counter Value: {$count}&lt;/h2&gt;\n      &lt;button onclick=\"setState('count', {$count} + 1)\"&gt;\n         Click to Increment\n      &lt;/button&gt;\n       {$script}\n   HTML;\n}\n</code></pre> <p>Side Effect</p> <p>This effect will run every time the 'count' state changes.</p>"},{"location":"hooks/use-effect/#controlling-the-effect-the-dependency-array","title":"Controlling the Effect: The Dependency Array","text":"<p>The second argument to <code>useEffect</code> is the dependency array. It tells PhpSPA when to run your effect.</p> Specific State ChangesRun Once on Load <p>Provide an array of state variables. The effect will run on the initial render and then again anytime one of those variables changes.</p> <pre><code>&lt;?php\n\nuseEffect($myCallback, [$stateA, $stateB]);\n</code></pre> <p>Provide an empty array <code>[]</code>. The effect will only run once when the component is first loaded. This is perfect for initial setup tasks, like fetching data from an API.</p> <pre><code>&lt;?php\n\nuseEffect(function () use (&amp;$script) {\n   // This runs only once.\n   $script = \"&lt;script&gt;console.log('Component has loaded!')&lt;/script&gt;\";\n}, []);\n</code></pre> <p>Dependency Control</p> <p>Use an empty array <code>[]</code> for effects that should only run once during component initialization.</p>"},{"location":"hooks/use-effect/#updating-state-inside-an-effect","title":"Updating State Inside an Effect","text":"<p>You can also update state from within an effect. This is useful for creating more complex, reactive logic.</p> <p>In this example, when the counter changes, the effect calculates a new value and immediately updates the state again.</p> <pre><code>&lt;?php\n\nfunction EffectExample() {\n   $counter = useState('counter', 0);\n   $message = useState('message', 'Waiting for an update...');\n\n   useEffect(function ($counter) use ($message) {\n      // Calculate a new value based on the current state\n      $newCounterValue = $counter() + 1;\n      $newMessage = \"Counter was {$counter}, but the effect changed it to {$newCounterValue}!\";\n\n      // Update the state from within the effect\n      $counter($newCounterValue);\n      $message($newMessage);\n\n   }, [$counter]); // This effect depends on the counter\n\n   return &lt;&lt;&lt;HTML\n      &lt;div&gt;\n         &lt;p&gt;{$message}&lt;/p&gt;\n         &lt;button onclick=\"setState('counter', {$counter} + 1)\"&gt;Trigger Effect&lt;/button&gt;\n      &lt;/div&gt;\n   HTML;\n}\n</code></pre> <p>Reactive Logic</p> <p>In this example, when the counter changes, the effect calculates a new value and immediately updates the state again.</p>"},{"location":"hooks/use-function/","title":"Calling PHP from JavaScript (<code>useFunction</code>)","text":"<p>Often, you need to run PHP logic \u2014 like saving to a database \u2014 without a full page reload. The <code>useFunction</code> hook makes this simple without creating separate API routes.</p> <p>Secure Bridge</p> <p>It securely exposes a PHP function so your client-side JavaScript can call it directly.</p> <p>Required Namespace</p> <p><pre><code>&lt;?php\nuse function Component\\useFunction;\n</code></pre> Include this at the top of your PHP files to use the <code>useFunction</code> hook.</p>"},{"location":"hooks/use-function/#syntax","title":"Syntax","text":"<pre><code>&lt;?php\n\nfunction phpFunction($arg) {\n    return \"result\";\n};\n\n$caller = useFunction(\"phpFunction\");\n</code></pre> <p>In JavaScript:</p> <pre><code>const result = await {$caller(\"'arg value'\")};\n</code></pre> <p>The <code>useFunction</code> hook wraps a PHP function and returns a caller that can be invoked from JavaScript.</p>"},{"location":"hooks/use-function/#example-a-simple-greeter-form","title":"Example: A Simple Greeter Form","text":"<p>Let's build a form where a user enters their name, and the server sends back a personalized greeting.</p> <p>1. Define the PHP Function</p> <pre><code>&lt;?php\n\nfunction sayHello(string $name): string {\n    return \"Hello, $name!\";\n};\n</code></pre> <p>This function accepts a name and returns a greeting.</p> <p>2. Wrap with useFunction</p> <pre><code>&lt;?php\n\n$greeter = useFunction(\"sayHello\");\n</code></pre> <p>This creates a JavaScript-callable version of your PHP function.</p> <p>3. Create the HTML Form</p> <pre><code>&lt;?php\n\necho &lt;&lt;&lt;HTML\n    &lt;input type=\"text\" id=\"nameInput\" placeholder=\"Enter your name\"&gt;\n    &lt;button id=\"greetBtn\"&gt;Greet Me&lt;/button&gt;\nHTML;\n</code></pre> <p>Simple input and button for user interaction.</p> <p>4. Call from JavaScript</p> <pre><code>const nameInput = document.getElementById('nameInput');\nconst greetBtn = document.getElementById('greetBtn');\n\ngreetBtn.onclick = async () =&gt; {\n    const name = nameInput.value;\n    const greeting = await {$greeter('name')}; // Take note: the value in the parameter is js code\n    alert(greeting);\n};\n</code></pre> <p>The JavaScript calls the PHP function and displays the result.</p>"},{"location":"hooks/use-function/#complete-example","title":"Complete Example","text":"<pre><code>&lt;?php\n\nuse PhpSPA\\Component;\nuse function Component\\useFunction;\n\n$greeterPage = new Component(function () {\n    // 1. Define the PHP function you want to call.\n    function sayHello(string $name, int $age): string {\n        return [\n            \"name\" =&gt; $name,\n            \"age\" =&gt; $age,\n            \"greeting\" =&gt; \"Hello, $name! You are $age years old\",\n        ];\n    };\n\n    // 2. Wrap your function with useFunction().\n    $greeter = useFunction(\"sayHello\");\n\n    echo &lt;&lt;&lt;HTML\n        &lt;input type=\"text\" id=\"nameInput\" placeholder=\"Enter your name\"&gt;\n        &lt;input type=\"number\" id=\"ageInput\" placeholder=\"Enter your age\"&gt;\n        &lt;button id=\"greetBtn\"&gt;Greet Me&lt;/button&gt;\n\n        &lt;script&gt;\n            const nameInput = document.getElementById('nameInput');\n            const ageInput = document.getElementById('ageInput');\n            const greetBtn = document.getElementById('greetBtn');\n\n            greetBtn.onclick = async () =&gt; {\n                const name = nameInput.value;\n                const age = Number(ageInput.value);\n\n                // 3. Call the PHP function from JavaScript!\n                const greeting = await {$greeter('name', 'age')};\n\n                // The returned value is the direct output of your PHP function.\n                console.log(greeting); // Shows a javascript object like:\n\n                // {\n                //    \"name\": \"Dave\",\n                //    \"age\": 17,\n                //    \"greeting\": \"Hello, Dave!\"\n                // }\n\n                alert(greeting.name); // Shows \"Dave\".\n            };\n        &lt;/script&gt;\n    HTML;\n});\n\n$greeterPage-&gt;route('/greeter');\n</code></pre> <p>How It Works</p> <p>When you echo the <code>$greeter('name')</code> object, it generates a JavaScript snippet like <code>phpspa.__call('some-secure-token', name)</code>. The arguments you pass to the caller in PHP are inserted directly as JavaScript expressions.</p> <p>Return Values</p> <p>The <code>phpspa.js</code> library handles the secure AJAX request and returns the exact data from your PHP function (string, array, object, etc.) as a JavaScript promise.</p>"},{"location":"hooks/use-state/","title":"Managing State with <code>useState</code>","text":"<p>State is the data in your component that can change over time. When state changes, PhpSPA automatically re-renders the component to reflect the new data. This is the key to creating dynamic and interactive UIs.</p> <p>The useState Hook</p> <p>The <code>useState</code> hook is how you add state to your components.</p>"},{"location":"hooks/use-state/#a-simple-counter","title":"A Simple Counter","text":"<p>Here's the classic counter example. The <code>useState</code> hook creates a state variable named <code>count</code> with an initial value of <code>0</code>.</p> <pre><code>&lt;?php\nuse function Component\\useState;\n\nfunction Counter() {\n   $count = useState('count', 0);\n\n   // The client-side setState() function updates the state and triggers a re-render.\n   return &lt;&lt;&lt;HTML\n      &lt;div&gt;\n         &lt;h2&gt;Counter Value: {$count}&lt;/h2&gt;\n         &lt;button onclick=\"setState('count', {$count} + 1)\"&gt;\n            Click to Increment\n         &lt;/button&gt;\n      &lt;/div&gt;\n   HTML;\n}\n</code></pre> <p>Understanding State Variables</p> <ul> <li><code>useState('count', 0)</code>: Declares a piece of state named <code>count</code> and sets its default value to <code>0</code></li> <li><code>{$count}</code>: When used in a string, the state variable automatically outputs its current value</li> <li><code>setState('count', ...)</code>: This is a global JavaScript function provided by PhpSPA to update state from the browser</li> </ul>"},{"location":"hooks/use-state/#rendering-lists-with-map","title":"Rendering Lists with <code>map()</code>","text":"<p>If your state holds an array, you can use the powerful <code>-&gt;map()</code> method to iterate over it and render a list of elements.</p> <p>This is perfect for rendering dynamic data, like a list of tasks.</p> <pre><code>&lt;?php\nuse function Component\\useState;\n\nfunction TodoList() {\n   $todos = useState('todos', [\n      ['id' =&gt; 1, 'text' =&gt; 'Learn phpspa'],\n      ['id' =&gt; 2, 'text' =&gt; 'Build an awesome app'],\n      ['id' =&gt; 3, 'text' =&gt; 'Deploy to production']\n   ]);\n\n   return &lt;&lt;&lt;HTML\n      &lt;div&gt;\n         &lt;h3&gt;My To-Do List&lt;/h3&gt;\n         &lt;ul&gt;\n            {$todos-&gt;map(fn($item) =&gt; \"&lt;li&gt;{$item['text']}&lt;/li&gt;\")}\n         &lt;/ul&gt;\n      &lt;/div&gt;\n   HTML;\n}\n</code></pre> <p>Dynamic Rendering</p> <p>The <code>-&gt;map()</code> method loops through each item in the <code>$todos</code> array and runs your function, concatenating the resulting HTML strings into a final list.</p>"},{"location":"navigations/link-component/","title":"Client-Side Navigation: The Link Component","text":"<p>To navigate between pages without a full browser reload, you must use the built-in <code>&lt;Component.Link /&gt;</code>. This component looks like a standard <code>&lt;a&gt;</code> tag, but it's much smarter\u2014it hooks into PhpSPA's router to fetch and render the new component on the fly, providing a seamless, SPA-like user experience. \ud83d\ude80</p> <p>Smart Navigation</p> <p>The <code>&lt;Component.Link /&gt;</code> component prevents full page reloads, giving your app that smooth, instant navigation feel.</p>"},{"location":"navigations/link-component/#basic-usage","title":"Basic Usage","text":"<p>The two main props are <code>to</code> for the destination URL and <code>children</code> for the link's text.</p> <pre><code>&lt;?php\n\nfunction AppHeader() {\n   return &lt;&lt;&lt;HTML\n      &lt;header&gt;\n         &lt;nav&gt;\n            &lt;Component.Link to=\"/\"&gt;Home&lt;/Component.Link&gt;\n            &lt;Component.Link to=\"/about\"&gt;About Us&lt;/Component.Link&gt;\n            &lt;Component.Link to=\"/contact\"&gt;Contact&lt;/Component.Link&gt;\n         &lt;/nav&gt;\n      &lt;/header&gt;\n   HTML;\n}\n</code></pre> <p>Navigation Example</p> <p>The component automatically handles routing and state management for you.</p>"},{"location":"navigations/link-component/#passing-additional-attributes","title":"Passing Additional Attributes","text":"<p>You can pass any standard HTML attribute like <code>class</code> or <code>id</code> directly to the component, and they will be added to the final <code>&lt;a&gt;</code> tag.</p> <pre><code>&lt;?php\n\nfunction AppFooter() {\n   return &lt;&lt;&lt;HTML\n      &lt;footer&gt;\n         &lt;Component.Link to=\"/privacy-policy\" class=\"footer-link\" id=\"privacy-link\"&gt;\n            Privacy Policy\n         &lt;/Component.Link&gt;\n      &lt;/footer&gt;\n   HTML;\n}\n</code></pre> <p>This will render the following HTML:</p> <pre><code>&lt;a href=\"/privacy-policy\" class=\"footer-link\" id=\"privacy-link\"&gt;\n   Privacy Policy\n&lt;/a&gt;\n</code></pre> <p>Best Practice</p> <p>Always use <code>&lt;Component.Link /&gt;</code> for navigating between your app's routes to get that smooth, instant page-load feel.</p>"},{"location":"navigations/navigate-component/","title":"Programmatic Navigation with <code>&lt;Navigate /&gt;</code>","text":"<p>While <code>&lt;Component.Link /&gt;</code> is perfect for user-driven navigation, you'll sometimes need to redirect a user automatically based on some logic (e.g., after a form submission). For this, use the <code>&lt;Component.Navigate /&gt;</code> component.</p> <p>Automatic Redirects</p> <p>When PhpSPA renders this component, it triggers an immediate, client-side redirect without a full page reload.</p>"},{"location":"navigations/navigate-component/#basic-usage","title":"Basic Usage","text":"<p>Simply render the component with a <code>path</code> prop. The redirect will happen as soon as the component is added to the page.</p> <pre><code>&lt;?php\nuse PhpSPA\\Http\\Request;\n\nfunction LoginPage(Request $request) {\n   $isLoggedIn = false;\n   if ($request-&gt;isMethod('POST')) {\n      // ... validate user credentials ...\n      if ($credentialsAreValid) {\n         $isLoggedIn = true;\n      }\n   }\n\n   // Conditionally render the Navigate component or the login form\n   if ($isLoggedIn) {\n      return '&lt;Component.Navigate path=\"/dashboard\" /&gt;';\n   }\n\n   return &lt;&lt;&lt;HTML\n      &lt;form method=\"POST\"&gt;\n         ...\n      &lt;/form&gt;\n   HTML;\n}\n</code></pre> <p>Conditional Redirect</p> <p>Perfect for post-login redirects or access control logic.</p>"},{"location":"navigations/navigate-component/#controlling-browser-history","title":"Controlling Browser History","text":"<p>The <code>&lt;Navigate /&gt;</code> component takes a <code>state</code> prop to control how it interacts with the browser's history.</p> push (Default)replace <p>Adds a new entry to the browser's history. The user can click the \"back\" button to return to the previous page.</p> <pre><code>&lt;Component.Navigate path=\"/dashboard\" state=\"push\" /&gt;\n</code></pre> <p>Replaces the current page in the browser's history. This is ideal for post-login redirects, as it prevents the user from clicking \"back\" to see the login form again.</p> <pre><code>&lt;Component.Navigate path=\"/dashboard\" state=\"replace\" /&gt;\n</code></pre> <p>Post-Login Redirects</p> <p>Use <code>state=\"replace\"</code> to prevent users from navigating back to the login page.</p> <pre><code>&lt;?php\n// Inside your component logic...\n\nif ($isLoggedIn) {\n   // Replace the login page in history so the user can't go back.\n   return '&lt;Component.Navigate path=\"/dashboard\" state=\"replace\" /&gt;';\n}\n</code></pre>"},{"location":"performance/assets-caching/","title":"Assets Caching","text":""},{"location":"performance/assets-caching/#performance-asset-caching","title":"Performance: Asset Caching","text":"<p>To improve performance and reduce server load, you can instruct the user's browser to cache your CSS and JavaScript assets.</p> <p>Cache Control</p> <p>Use the <code>-&gt;assetCacheHours()</code> method on your <code>$app</code> instance to set a cache duration. The library will automatically append a version query string to your asset URLs to handle cache-busting.</p> <pre><code>&lt;?php\n\nuse PhpSPA\\App;\n\n$app = new App($layout);\n\n// Tell the browser to cache all CSS/JS assets for 24 hours.\n$app-&gt;assetCacheHours(24);\n\n// For no caching (useful in development), set it to 0.\n$app-&gt;assetCacheHours(0);\n</code></pre> <p>Development vs Production</p> <ul> <li>Development: Set to <code>0</code> for no caching, so changes are immediately visible</li> <li>Production: Set to <code>24</code> (or higher) for optimal performance and reduced server load</li> </ul>"},{"location":"performance/html-compression/","title":"Performance: HTML Compression","text":"<p>To ensure your application is as fast as possible, PhpSPA includes a powerful, built-in HTML compressor. It automatically minifies your final HTML output by removing whitespace, comments, and other unnecessary characters, which reduces the page size and leads to faster load times. \u26a1</p> <p>Auto-Detection</p> <p>By default, PhpSPA tries to auto-detect the best settings. However, you can take full control for fine-tuned performance.</p>"},{"location":"performance/html-compression/#automatic-compression-default-behavior","title":"Automatic Compression (Default Behavior)","text":"<p>PhpSPA automatically initializes the HTML compressor when you create your <code>App</code> instance. The second parameter controls this behavior and is set to <code>true</code> by default.</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\n\n// Auto-initialization is enabled by default\n$app = new App($layout);\n\n// This is the same as:\n$app = new App($layout, true);\n</code></pre> <p>Smart Detection</p> <p>When auto-initialization is enabled, PhpSPA automatically detects the best compression level based on your server environment. You don't need to manually configure anything!</p>"},{"location":"performance/html-compression/#disabling-auto-initialization","title":"Disabling Auto-Initialization","text":"<p>If you want full manual control over compression, you can disable auto-initialization:</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\n\n// Disable auto-initialization\n$app = new App($layout, false);\n\n// Now you must manually configure compression if you want it\n$app-&gt;compression(Compressor::LEVEL_AGGRESSIVE, true);\n</code></pre> <p>When to Disable</p> <p>Disable auto-initialization only if you need precise control over compression settings for specific use cases.</p>"},{"location":"performance/html-compression/#environment-based-configuration-recommended","title":"Environment-Based Configuration (Recommended)","text":"<p>The easiest way to manage compression is to set the application's environment. PhpSPA will then apply a sensible preset for you.</p> developmentproduction <p>Compression is disabled to make debugging easier.</p> <pre><code>&lt;?php\nuse PhpSPA\\Compression\\Compressor;\n\n$app-&gt;compressionEnvironment(Compressor::ENV_DEVELOPMENT);\n</code></pre> <p>A high level of compression is enabled for maximum performance.</p> <pre><code>&lt;?php\nuse PhpSPA\\Compression\\Compressor;\n\n$app-&gt;compressionEnvironment(Compressor::ENV_PRODUCTION);\n</code></pre> <p>Environment Presets</p> <p>Set the environment to automatically configure compression with sensible defaults.</p>"},{"location":"performance/html-compression/#manual-compression-control","title":"Manual Compression Control","text":"<p>For more granular control, you can manually set the compression level and enable or disable Gzip.</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\nuse PhpSPA\\Compression\\Compressor;\n\n$app = new App($layout);\n\n// Manually set the highest level of compression and enable Gzip\n$app-&gt;compression(Compressor::LEVEL_EXTREME, true);\n</code></pre> <p>Compression Levels</p> <p>There are several levels available, from basic to extreme:</p> <ul> <li><code>Compressor::LEVEL_NONE</code>: No compression is applied</li> <li><code>Compressor::LEVEL_BASIC</code>: Removes comments and basic whitespace</li> <li><code>Compressor::LEVEL_AGGRESSIVE</code>: Performs more intense whitespace removal</li> <li><code>Compressor::LEVEL_EXTREME</code>: Applies the most aggressive minification for the smallest possible file size</li> </ul>"},{"location":"performance/managing-styles-and-scripts/","title":"Managing Styles &amp; Scripts \ud83c\udfa8","text":"<p>PhpSPA offers a powerful way to manage your CSS and JavaScript. You can write them directly in PHP, and the library will automatically serve them as optimized, cache-busting external files for maximum performance.</p> <p>Asset Management</p> <p>PhpSPA automatically generates versioned, cacheable asset files for optimal performance.</p>"},{"location":"performance/managing-styles-and-scripts/#global-assets","title":"Global Assets","text":"<p>For styles and scripts that apply to your entire site, attach them directly to your <code>$app</code> instance.</p> <p>The methods <code>styleSheet()</code> and <code>script()</code> accept a callable that returns your raw code. For better organization, it's recommended to keep this code in separate files.</p> <p>Example (<code>styles/GlobalStyle.php</code>):</p> <pre><code>&lt;?php\n// returns a callable with your CSS code\nreturn fn () =&gt; &lt;&lt;&lt;CSS\n   body {\n      background-color: #f8f9fa;\n      font-family: sans-serif;\n   }\nCSS;\n</code></pre> <p>Example (<code>index.php</code>):</p> <pre><code>&lt;?php\n$app = new App($layout);\n\n// Attach the global style and script from their files\n$app-&gt;styleSheet(require 'styles/GlobalStyle.php', 'global-styles');\n$app-&gt;script(require 'scripts/GlobalScript.php', 'global-scripts');\n</code></pre> <p>Cache-Busting</p> <p>Behind the scenes, PhpSPA creates unique, versioned links like <code>/phpspa/assets/global-styles-a1b2c3d4.css</code>, which allows the browser to cache them effectively. The optional second parameter (<code>'global-styles'</code>) is a name added to the file for easier debugging.</p>"},{"location":"performance/managing-styles-and-scripts/#component-specific-assets","title":"Component-Specific Assets","text":"<p>You also have two ways to add assets that only belong to a specific component.</p> Method Chaining (Cached)Inline Tags (Uncached) <p>This works just like global assets. The code is served in its own cached file.</p> <pre><code>&lt;?php\n$profileComponent = new Component(fn() =&gt; '&lt;div&gt;...&lt;/div&gt;');\n\n$profileComponent\n   -&gt;route('/profile')\n   -&gt;styleSheet(fn() =&gt; '.profile-card { border: 1px solid #ccc; }');\n</code></pre> <p>For very small, component-specific tweaks, you can write standard <code>&lt;style&gt;</code> and <code>&lt;script&gt;</code> tags directly inside your component's <code>heredoc</code> string.</p> <pre><code>&lt;?php\nfunction UserProfile() {\n   return &lt;&lt;&lt;HTML\n      &lt;style&gt;\n         /* This style is not served as a separate cached file */\n         .profile-card {\n            padding: 20px;\n         }\n      &lt;/style&gt;\n\n      &lt;div class=\"profile-card\"&gt;\n         &lt;h2&gt;User Profile&lt;/h2&gt;\n      &lt;/div&gt;\n   HTML;\n}\n</code></pre> <p>Inline Assets</p> <p>Important: This is the simplest method, but these inline assets will not be externally cached by the browser. It's best reserved for small, non-critical snippets.</p>"},{"location":"references/","title":"API References","text":"<ul> <li> <p> Complete Documentation</p> <p>Comprehensive guides for all PhpSPA APIs and utilities</p> </li> <li> <p> Code Examples</p> <p>Practical examples for every feature</p> </li> <li> <p> Best Practices</p> <p>Learn the recommended patterns and techniques</p> </li> <li> <p> Always Current</p> <p>Updated documentation for the latest version</p> </li> </ul>"},{"location":"references/#client-runtime","title":"Client Runtime","text":"<ul> <li> <p> Vite + TypeScript Runtime </p> <p>Learn how the <code>@dconco/phpspa</code> package bootstraps navigation, state sync, and client helpers.</p> <p> Open guide</p> </li> </ul>"},{"location":"references/#http-networking","title":"HTTP &amp; Networking","text":"<ul> <li> <p> Response API</p> <p>Build and customize HTTP responses with fluent API</p> <p> Learn more</p> </li> <li> <p> useFetch Hook </p> <p>Async HTTP client with parallel execution support</p> <p> Learn more</p> </li> <li> <p> Router API </p> <p>Advanced routing with nested groups, middleware, and prefixing</p> <p> Learn more</p> </li> </ul>"},{"location":"references/#helpers-utilities","title":"Helpers &amp; Utilities","text":"<ul> <li> <p> fmt() Helper </p> <p>Type-safe prop passing with automatic serialization</p> <p> Learn more</p> </li> <li> <p> File Import Utility</p> <p>Secure file imports with validation and metadata</p> <p> Learn more</p> </li> <li> <p> DOM Utilities</p> <p>Dynamic page title manipulation</p> <p> Learn more</p> </li> </ul>"},{"location":"references/#performance","title":"Performance","text":"<ul> <li> <p> Native Compression (C++ FFI)</p> <p>Enable lightning-fast HTML/CSS/JS minification with the C++ compressor</p> <p> Learn more</p> </li> </ul>"},{"location":"references/#component-features","title":"Component Features","text":"<ul> <li> <p> Component Preloading </p> <p>Load multiple components on different target IDs for complex layouts</p> <p> Learn more</p> </li> <li> <p> Client-Side useEffect </p> <p>Manage side effects in component scripts</p> <p> Learn more</p> </li> <li> <p> Client-Side useCallback </p> <p>Memoize DOM/event handlers with state-aware dependencies</p> <p> Learn more</p> </li> </ul>"},{"location":"references/#browse-by-category","title":"Browse by Category","text":"HooksHelpersComponentsPerformance Hook Description Version <code>useFetch()</code> Async HTTP client with parallel execution v2.0.1 <code>useState()</code> Reactive state management v2.0.0 <code>useEffect() (PHP)</code> Side effects and lifecycle hooks v2.0.0 <code>useEffect() (JS)</code> Client-side side effects v2.0.4 <code>useCallback() (JS)</code> Stable callbacks with dependency tracking v2.0.8 <code>useFunction()</code> Call PHP functions from JavaScript v1.1.5 Helper Description Version <code>DOM::Title()</code> Get or set page title dynamically v2.0.4 <code>fmt()</code> Type preservation for component props v2.0.1 <code>import()</code> Secure file imports v1.1.0 <code>response()</code> HTTP response builder v1.1.8 <code>router()</code> Router instance access v2.0.4 Feature Description Version Component Meta Tags Route/global SEO metadata with <code>-&gt;meta()</code> v2.0.5 Component Preloading Multi-section layouts with independent updates v2.0.4 <code>&lt;Component.Link&gt;</code> Client-side navigation v1.1.0 <code>&lt;Component.Csrf&gt;</code> CSRF token management v1.1.5 <code>&lt;Component.Navigate&gt;</code> Programmatic navigation v1.1.0 Feature Description Version Native Compression (C++ FFI) Lightning-fast HTML/CSS/JS minification v2.0.3 HTML Compression Enable compression for faster page loads v1.1.5 Assets Caching Configure asset caching duration v1.1.7 Managing Styles &amp; Scripts Global and component-level asset management v1.1.7"},{"location":"references/component-meta/","title":"Component Meta Tags","text":"<p>New in v2.0.5</p> <p>Attach SEO metadata to any route directly from the component definition.</p> <p>PhpSPA components can now describe their own <code>&lt;meta&gt;</code> tags through the fluent <code>-&gt;meta()</code> method. Each call accepts named attributes (e.g., <code>name</code>, <code>property</code>, <code>httpEquiv</code>) plus the <code>content</code> value. Tags are rendered only on the initial HTML response, so SPA navigations stay lightweight.</p>"},{"location":"references/component-meta/#why-use-meta","title":"Why use <code>-&gt;meta()</code>?","text":"<ul> <li>Keep titles and metadata close to the component they describe</li> <li>Emit Open Graph, Twitter, or HTTP-EQUIV tags without editing the global layout</li> <li>Prevent duplication \u2014 PhpSPA deduplicates identical meta signatures before injecting them</li> </ul>"},{"location":"references/component-meta/#basic-usage","title":"Basic Usage","text":"<pre><code>&lt;?php\n\nnew Component(...)\n   -&gt;route('/')\n   -&gt;title('PhpSPA Design System')\n   -&gt;meta(name: 'description', content: 'Design-forward PhpSPA starter')\n   -&gt;meta(name: 'keywords', content: 'PhpSPA, PHP SPA, Tailwind, Vite');\n</code></pre> <p>Each <code>-&gt;meta()</code> call corresponds to one <code>&lt;meta&gt;</code> element. Only <code>content</code> (or <code>charset</code>) is required, but you can mix and match other attributes freely.</p>"},{"location":"references/component-meta/#open-graph-http-equiv-example","title":"Open Graph &amp; HTTP-EQUIV Example","text":"<pre><code>&lt;?php\n\nnew Component(...)\n   -&gt;route('/docs')\n   -&gt;meta(property: 'og:title', content: 'PhpSPA Docs')\n   -&gt;meta(property: 'og:description', content: 'Server-driven SPA workflow')\n   -&gt;meta(httpEquiv: 'refresh', content: '120')\n   -&gt;meta(charset: 'UTF-8');\n</code></pre> <p>Initial render only</p> <p>Meta tags are rendered server-side when the page first loads. Client-side navigations keep the existing head content unchanged unless another component defines new metadata.</p>"},{"location":"references/component-meta/#custom-attributes","title":"Custom Attributes","text":"<p>Need to attach bespoke attributes (e.g., <code>data-*</code> or <code>media</code>)? Pass them through the final <code>$attributes</code> argument.</p> <pre><code>&lt;?php\n\nnew Component(...)\n   -&gt;meta(name: 'twitter:image', content: 'https://cdn.example.com/cover.png', attributes: [\n      'data-theme' =&gt; 'dark',\n      'media' =&gt; '(prefers-color-scheme: dark)'\n   ]);\n</code></pre> <p>Resulting markup:</p> <pre><code>&lt;meta name=\"twitter:image\" content=\"https://cdn.example.com/cover.png\" data-theme=\"dark\" media=\"(prefers-color-scheme: dark)\"&gt;\n</code></pre>"},{"location":"references/component-meta/#global-defaults-with-appmeta","title":"Global Defaults with <code>App::meta()</code>","text":"<p>Need baseline tags (site name, theme color, analytics hints) before any component runs? Register them once on the application:</p> <pre><code>&lt;?php\n\n$app = (new App(require 'layout.php'))\n   -&gt;meta(name: 'application-name', content: 'PhpSPA Starter')\n   -&gt;meta(property: 'og:site_name', content: 'PhpSPA Starter')\n   -&gt;meta(name: 'theme-color', content: '#050A1F');\n</code></pre> <p>Global entries merge with each component's own metadata. Duplicates are deduplicated automatically, and component-defined tags take precedence when the same signature appears.</p>"},{"location":"references/compression/","title":"\u26a1 Native Compression (C++ FFI)","text":"<p>New in v2.0.3</p> <p> Native C++ compressor for lightning-fast HTML/CSS/JS minification</p> <p>Performance First</p> <p>Supercharge your app with zero-overhead native compression. No extra PHP dependencies\u2014just pure speed! \ud83d\ude80</p>"},{"location":"references/compression/#quick-setup","title":"\ud83c\udfaf Quick Setup","text":""},{"location":"references/compression/#1-enable-ffi-extension","title":"1\ufe0f\u20e3 Enable FFI Extension","text":"<p>Edit your <code>php.ini</code> configuration:</p> <pre><code>ffi.enable=true\nextension=ffi\n</code></pre> <p>Finding your php.ini</p> <p>Run <code>php --ini</code> to locate your configuration file, or check <code>phpinfo()</code> output.</p>"},{"location":"references/compression/#2-download-prebuilt-libraries-optional","title":"2\ufe0f\u20e3 Download Prebuilt Libraries (Optional)","text":"<p>PhpSPA auto-detects the compressor library from your installation. Windows and Linux binaries are included by default.</p> <p>macOS Users</p> <p>The macOS binary (<code>libcompressor.dylib</code>) is not included in the Composer package. Download it manually and configure the path:</p> <p>Latest Release</p> <p> Download from GitHub Releases</p> Platform Library File Direct Link Included via Composer Windows <code>compressor.dll</code> Download \u2705 Yes Linux <code>libcompressor.so</code> Download \u2705 Yes macOS <code>libcompressor.dylib</code> Download \u274c No (manual download required) <p>Configure custom path (macOS required):</p> <pre><code>&lt;?php\n// Set before creating the App instance\n$path = __DIR__ . '/path/to/libcompressor.dylib';\nputenv(\"PHPSPA_COMPRESSOR_LIB=$path\");\n\n$app = new \\PhpSPA\\App();\n</code></pre> <p>Or via shell environment:</p> <pre><code>export PHPSPA_COMPRESSOR_LIB=\"/absolute/path/to/libcompressor.dylib\"\n</code></pre>"},{"location":"references/compression/#3-force-native-mode-optional","title":"3\ufe0f\u20e3 Force Native Mode (Optional)","text":"<p>To require native compression (fails if library unavailable):</p> <pre><code>&lt;?php\n// Set before creating the App instance\nputenv('PHPSPA_COMPRESSION_STRATEGY=native');\n\n$app = new \\PhpSPA\\App();\n</code></pre> <p>Or via shell environment:</p> <pre><code>export PHPSPA_COMPRESSION_STRATEGY=native\n</code></pre> <p>Production Recommendation</p> <p>Leave this unset to enable automatic fallback to PHP compression if the native library is unavailable.</p>"},{"location":"references/compression/#how-it-works","title":"\ud83d\udd27 How It Works","text":"<pre><code>graph LR\n    A[PhpSPA Request] --&gt; B{\"FFI Available?\"}\n    B --&gt;|Yes| C{\"Native Library Found?\"}\n    B --&gt;|No| E[PHP Fallback]\n    C --&gt;|Yes| D[\"\u26a1 Native Compression\"]\n    C --&gt;|No| E\n    D --&gt; F[Response]\n    E --&gt; F</code></pre> Feature Description \ud83d\udd0d Auto-detect PhpSPA automatically finds the compression library in standard locations \ud83c\udf9b\ufe0f Manual override Set <code>PHPSPA_COMPRESSOR_LIB</code> environment variable for custom paths \ud83d\udd10 Strategy control Use <code>PHPSPA_COMPRESSION_STRATEGY=native</code> to enforce native-only mode \u2705 Verification Check <code>X-PhpSPA-Compression-Engine: native</code> in HTTP response headers"},{"location":"references/compression/#troubleshooting","title":"\ud83d\udc1b Troubleshooting","text":"<p>FFI Extension Not Available</p> <p>Problem: <code>ffi.enable</code> is not set or the extension is missing.</p> <p>Solution: <pre><code># Check current PHP configuration\nphp -i | grep ffi\n\n# Ensure ffi.enable=true in the correct php.ini\n# Restart your web server after changes\n</code></pre></p> <p>Library Not Found</p> <p>Problem: Native compressor library cannot be located.</p> <p>Solution: <pre><code># Set explicit path\nexport PHPSPA_COMPRESSOR_LIB=\"/full/path/to/libcompressor.so\"\n\n# Or place library in one of these auto-detected paths inside the phpspa library:\n# - vendor/dconco/phpspa/build/MinSizeRel/\n# - vendor/dconco/phpspa/build/Release/\n# - vendor/dconco/phpspa/build/\n# - vendor/dconco/phpspa/src/bin/\n</code></pre></p> <p>Fallback Mode Active</p> <p>Problem: Native compression failed; PHP fallback is being used.</p> <p>Solution: Check the response header <code>X-PhpSPA-Compression-Engine</code>. If it shows <code>php</code> instead of <code>native</code>:</p> <ul> <li>Verify FFI is enabled: <code>php -m | grep FFI</code></li> <li>Confirm library exists: <code>ls -la /path/to/libcompressor.so</code></li> <li>Check file permissions (must be readable by web server user)</li> </ul>"},{"location":"references/compression/#verification","title":"\ud83d\udcca Verification","text":"<p>Check which compression engine handled your request:</p> <pre><code>X-PhpSPA-Compression-Engine: native\nX-PhpSPA-Compression-Level: 2\n</code></pre>"},{"location":"references/compression/#enable-compression-in-your-app","title":"\ud83d\udcbb Enable Compression in Your App","text":""},{"location":"references/compression/#basic-setup","title":"Basic Setup","text":"<pre><code>&lt;?php\nuse PhpSPA\\Compression\\Compressor;\n\n// Enable aggressive compression with native engine\n$app-&gt;compression(Compressor::LEVEL_AGGRESSIVE, true);\n</code></pre>"},{"location":"references/compression/#compression-levels","title":"Compression Levels","text":"Level Constant Description 0 <code>LEVEL_DISABLED</code> No compression 1 <code>LEVEL_BASIC</code> Remove comments only 2 <code>LEVEL_AGGRESSIVE</code> Basic + whitespace removal 3 <code>LEVEL_EXTREME</code> Aggressive + CSS/JS minification"},{"location":"references/compression/#programmatic-api","title":"\ud83c\udfa8 Programmatic API","text":""},{"location":"references/compression/#available-methods","title":"Available Methods","text":"compressWithLevel()getCompressionEngine() <p>Minify HTML programmatically without affecting runtime configuration:</p> <pre><code>&lt;?php\nuse PhpSPA\\Compression\\Compressor;\n\n$html = '&lt;div&gt;\\n  &lt;span&gt; Hello World &lt;/span&gt;\\n&lt;/div&gt;';\n\n$compressed = Compressor::compressWithLevel(\n    $html, \n    Compressor::LEVEL_AGGRESSIVE\n);\n\necho $compressed;\n// Output: &lt;div&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;/div&gt;\n</code></pre> <p>Signature</p> <pre><code>&lt;?php\npublic static function compressWithLevel(\n    string $html, \n    int $level\n): string\n</code></pre> <p>Inspect which engine handled the last compression:</p> <pre><code>&lt;?php\nuse PhpSPA\\Compression\\Compressor;\n\n$compressed = Compressor::compressWithLevel($html, Compressor::LEVEL_EXTREME);\n\n$engine = Compressor::getCompressionEngine();\n// Returns: 'native' | 'php' | 'disabled'\n\nif ($engine === 'native') {\n    echo \"\u2705 Using native C++ compression\";\n}\n</code></pre> <p>Signature</p> <pre><code>&lt;?php\npublic static function getCompressionEngine(): string\n</code></pre>"},{"location":"references/compression/#complete-example","title":"Complete Example","text":"<pre><code>&lt;?php\nuse PhpSPA\\Compression\\Compressor;\n\n$html = &lt;&lt;&lt;HTML\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Test Page&lt;/title&gt;\n    &lt;style&gt;\n      body { margin: 0; padding: 0; }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=\"container\"&gt;\n      &lt;h1&gt;Hello World&lt;/h1&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\nHTML;\n\n// Compress at extreme level\n$compressed = Compressor::compressWithLevel($html, Compressor::LEVEL_EXTREME);\n\n// Check engine used\n$engine = Compressor::getCompressionEngine();\n\necho \"Engine: {$engine}\\n\";\necho \"Original: \" . strlen($html) . \" bytes\\n\";\necho \"Compressed: \" . strlen($compressed) . \" bytes\\n\";\necho \"Savings: \" . round((1 - strlen($compressed) / strlen($html)) * 100, 1) . \"%\\n\";\n</code></pre> <p>Strategy Behavior</p> <p><code>compressWithLevel()</code> respects <code>PHPSPA_COMPRESSION_STRATEGY</code>. If set to <code>native</code> and the library fails, an exception is thrown.</p>"},{"location":"references/compression/#additional-resources","title":"\ud83d\udcda Additional Resources","text":"<p>Learn More</p> <p> Full Compression Guide</p> <p>Explore compression best practices, performance benchmarks, and advanced configuration options.</p>"},{"location":"references/dom-utilities/","title":"DOM Utilities","text":"<p>New in v2.0.4</p> <p> DOM utilities for dynamic page manipulation</p>"},{"location":"references/dom-utilities/#domtitle","title":"<code>DOM::Title()</code>","text":"<p>Get or set the page title dynamically from any component.</p>"},{"location":"references/dom-utilities/#usage","title":"Usage","text":"<pre><code>&lt;?php\nuse PhpSPA\\DOM;\n\n// Set title\nDOM::Title('User Profile - My App');\n\n// Get title\n$currentTitle = DOM::Title();\n</code></pre>"},{"location":"references/dom-utilities/#dynamic-example","title":"Dynamic Example","text":"<pre><code>&lt;?php\nuse PhpSPA\\Component;\nuse PhpSPA\\DOM;\n\n$userProfile = (new Component(function(array $path) {\n   $username = $path['username'];\n\n   // Set dynamic title based on data\n   DOM::Title(\"{$username} - Profile\");\n\n   return \"&lt;h1&gt;{$username}&lt;/h1&gt;\";\n}))-&gt;route('/user/{username: string}');\n</code></pre> <p>Persistence</p> <p>The title persists across component navigations until explicitly changed by another component or a page reload.</p>"},{"location":"references/file-import-utility/","title":"File Import Utility","text":""},{"location":"references/file-import-utility/#overview","title":"Overview","text":"<p>The file import utility provides a secure way to handle file imports with validation and returns a rich <code>ImportedFile</code> object.</p>"},{"location":"references/file-import-utility/#must-import-namespace","title":"Must Import Namespace","text":"<pre><code>&lt;?php\nuse function Component\\import;\nuse PhpSPA\\Exceptions\\AppException;\n</code></pre>"},{"location":"references/file-import-utility/#function-reference","title":"Function Reference","text":""},{"location":"references/file-import-utility/#import","title":"<code>import()</code>","text":"<pre><code>function import(string $file): ImportedFile\n</code></pre>"},{"location":"references/file-import-utility/#description","title":"Description","text":"<p>Imports a file with validation and returns an <code>ImportedFile</code> object.</p>"},{"location":"references/file-import-utility/#example","title":"Example","text":"<pre><code>&lt;?php\n\n   $image = import('assets/profile.jpg');\n\n   echo \"&lt;img src='{$image}'&gt;\";\n</code></pre>"},{"location":"references/file-import-utility/#metadata-methods","title":"Metadata Methods","text":"Method Returns Description <code>getContentType()</code> string File MIME type <code>getContentLength()</code> int Base64 content length <code>getOriginalSize()</code> int Original file size in bytes <code>getLocation()</code> string Original file path <code>getFilename()</code> string Filename without path <code>getExtension()</code> string File extension <code>isImage()</code> bool Whether file is an image"},{"location":"references/file-import-utility/#content-methods","title":"Content Methods","text":"Method Returns Description <code>getRawContent()</code> string Decoded file content <code>getBase64Content()</code> string Base64 encoded content <code>saveAs(string $dest)</code> bool Saves file to new location"},{"location":"references/file-import-utility/#usage-examples","title":"Usage Examples","text":""},{"location":"references/file-import-utility/#basic-file-import","title":"Basic File Import","text":"<pre><code>&lt;?php\nuse PhpSPA\\Exceptions\\AppException;\nuse function PhpSPA\\Component\\import;\n\ntry {\n    $file = import('documents/report.pdf');\n    echo 'File size: ' . $file-&gt;getOriginalSize() . ' bytes';\n} catch (AppException $e) {\n    error_log($e-&gt;getMessage());\n}\n</code></pre>"},{"location":"references/file-import-utility/#image-handling","title":"Image Handling","text":"<pre><code>&lt;?php\n$image = import('gallery/photo.jpg');\n\nif ($image-&gt;isImage()) {\n    echo '&lt;img src=\"' . $image . '\" \n         alt=\"' . htmlspecialchars($image-&gt;getFilename()) . '\"\n         class=\"img-fluid\"&gt;';\n}\n</code></pre>"},{"location":"references/file-import-utility/#file-saving","title":"File Saving","text":"<pre><code>&lt;?php\n$imported = import('temp/upload.tmp');\n\nif ($imported-&gt;saveAs('archive/' . $imported-&gt;getFilename())) {\n    echo 'File archived successfully';\n}\n</code></pre>"},{"location":"references/file-import-utility/#error-handling","title":"Error Handling","text":"<p>Common error scenarios:</p> <pre><code>&lt;?php\ntry {\n    // Attempt to import non-existent file\n    $file = import('missing.png');\n} catch (AppException $e) {\n    echo $e-&gt;getMessage(); // \"Unable to get file: missing.png\"\n}\n\ntry {\n    // Attempt to import large file\n    $file = import('large-video.mp4');\n} catch (AppException $e) {\n    echo $e-&gt;getMessage(); // \"File too large to import: large-video.mp4\"\n}\n</code></pre>"},{"location":"references/file-import-utility/#best-practices","title":"Best Practices","text":"<ol> <li>Always wrap imports in try-catch blocks</li> <li>Verify file types before processing</li> <li>Use <code>isImage()</code> for image-specific handling</li> <li>Store large files directly rather than using data URIs</li> </ol>"},{"location":"references/preloading-component/","title":"Component Preloading &amp; Multi-Section Layouts","text":"<p>New in v2.0.4</p> <p> Component preloading for building complex, multi-section layouts</p>"},{"location":"references/preloading-component/#overview","title":"\ud83d\ude80 Overview","text":"<p>PhpSPA v2.0.4 introduces powerful features for building complex layouts where different sections update independently. Perfect for messaging apps, dashboards, and multi-panel interfaces.</p> <p>Key Features:</p> <ul> <li><code>name()</code> - Assign unique identifiers to components</li> <li><code>preload()</code> - Load multiple components simultaneously on different target IDs</li> <li><code>exact()</code> - Revert to default content when navigating away</li> <li><code>pattern()</code> - Match routes using fnmatch patterns (e.g., <code>/blog/*</code>)</li> <li><code>method()</code> - Accept multiple HTTP methods</li> <li><code>route()</code> - Define multiple routes</li> </ul>"},{"location":"references/preloading-component/#real-world-example-whatsapp-web-clone","title":"\ud83d\udcf1 Real-World Example: WhatsApp Web Clone","text":"<p>Build a messaging interface with independent user list and chat sections.</p>"},{"location":"references/preloading-component/#layout","title":"Layout","text":"<pre><code>&lt;?php\nfunction Layout() {\n   return &lt;&lt;&lt;HTML\n      &lt;div class=\"container\"&gt;\n         &lt;section id=\"users\"&gt;&lt;/section&gt;\n         &lt;section id=\"chat\"&gt;\n            &lt;div class=\"welcome\"&gt;Welcome! Select a user to start chatting.&lt;/div&gt;\n         &lt;/section&gt;\n      &lt;/div&gt;\n   HTML;\n}\n</code></pre>"},{"location":"references/preloading-component/#components","title":"Components","text":""},{"location":"references/preloading-component/#step-1-create-the-user-list-component","title":"Step 1: Create the User List Component","text":"<p>This component shows on the homepage and displays all available users to chat with.</p> <pre><code>&lt;?php\nuse PhpSPA\\Component;\n\n$userList = (new Component(function() {\n   $users = [\n      ['id' =&gt; 1, 'name' =&gt; 'John Doe'],\n      ['id' =&gt; 2, 'name' =&gt; 'Jane Smith'],\n   ];\n\n   $html = '&lt;div class=\"user-list\"&gt;&lt;h3&gt;Chats&lt;/h3&gt;';\n   foreach ($users as $user) {\n      $html .= \"&lt;a href='/chat/{$user['id']}'&gt;{$user['name']}&lt;/a&gt;\";\n   }\n   return $html . '&lt;/div&gt;';\n}))\n   -&gt;route('/')           // Shows on homepage\n   -&gt;targetID('users')    // Renders in id=\"users\"\n   -&gt;name('userList');    // Named for preloading\n</code></pre> <p>Key points:</p> <ul> <li><code>route('/')</code> - This component renders on the homepage</li> <li><code>targetID('users')</code> - Content goes into the <code>&lt;section id=\"users\"&gt;</code> element</li> <li><code>name('userList')</code> - Assigns a unique name so other components can reference it</li> </ul>"},{"location":"references/preloading-component/#step-2-create-the-chat-component","title":"Step 2: Create the Chat Component","text":"<p>This component displays messages for a specific user. The magic happens with <code>preload()</code> and <code>exact()</code>.</p> <pre><code>&lt;?php\n$chatView = (new Component(function(array $path) {\n   $userId = $path['id'];\n   $messages = getMessages($userId); // Your database function\n\n   $html = \"&lt;div class='chat-header'&gt;Chat with User {$userId}&lt;/div&gt;\";\n   foreach ($messages as $msg) {\n      $html .= \"&lt;div class='message'&gt;{$msg['text']}&lt;/div&gt;\";\n   }\n   return $html;\n}))\n   -&gt;route('/chat/{id: int}')      // Matches /chat/1, /chat/2, etc.\n   -&gt;targetID('chat')              // Renders in id=\"chat\"\n   -&gt;preload('userList')           // CRITICAL: Also load user list\n   -&gt;exact();                      // Revert to welcome when navigating away\n</code></pre> <p>Key points:</p> <ul> <li><code>route('/chat/{id: int}')</code> - Matches <code>/chat/1</code>, <code>/chat/2</code>, etc. with typed parameter</li> <li><code>targetID('chat')</code> - Content goes into the <code>&lt;section id=\"chat\"&gt;</code> element</li> <li><code>preload('userList')</code> - This is the magic! Also loads the user list component</li> <li><code>exact()</code> - When navigating away from this route, revert to the default welcome message</li> </ul>"},{"location":"references/preloading-component/#step-3-register-components-run","title":"Step 3: Register Components &amp; Run","text":"<pre><code>&lt;?php\n$app = new App(Layout(...))\n   -&gt;attach($userList)\n   -&gt;attach($chatView)\n   -&gt;run();\n</code></pre>"},{"location":"references/preloading-component/#what-happens","title":"What Happens","text":"<p>On <code>/</code> route: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 User List    \u2502 Welcome Message \u2502\n\u2502 \u2022 John Doe   \u2502 Select a user   \u2502\n\u2502 \u2022 Jane Smith \u2502 to start...     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>On <code>/chat/1</code> route: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 User List    \u2502 Chat with John  \u2502\n\u2502 \u2022 John Doe   \u2502 John: Hey!      \u2502\n\u2502 \u2022 Jane Smith \u2502 You: Hi!        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nBoth sections render because of preload()\n</code></pre></p> <p>Navigate back to <code>/</code>: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 User List    \u2502 Welcome Message \u2502\n\u2502 \u2022 John Doe   \u2502 Select a user   \u2502\n\u2502 \u2022 Jane Smith \u2502 to start...     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nChat reverts to welcome because of exact()\n</code></pre></p>"},{"location":"references/preloading-component/#method-reference","title":"\u2699\ufe0f Method Reference","text":""},{"location":"references/preloading-component/#namestring-value","title":"<code>name(string $value)</code>","text":"<p>Assigns unique identifier for preloading reference.</p> <pre><code>&lt;?php\n$sidebar = (new Component(...))-&gt;name('sidebar');\n</code></pre>"},{"location":"references/preloading-component/#preloadstring-componentnames","title":"<code>preload(string ...$componentNames)</code>","text":"<p>Loads additional named components together.</p> <pre><code>&lt;?php\n$main = (new Component(...))\n   -&gt;preload('sidebar', 'navbar', 'footer');\n</code></pre>"},{"location":"references/preloading-component/#exact","title":"<code>exact()</code>","text":"<p>Reverts to default content when route doesn't match.</p> <pre><code>&lt;?php\n$profile = (new Component(...))\n   -&gt;route('/profile/{id: int}')\n   -&gt;exact(); // Reverts to default when navigating away\n</code></pre> <p>Without <code>exact()</code>: Stale content remains visible With <code>exact()</code>: Clean revert to default content</p>"},{"location":"references/preloading-component/#pattern","title":"<code>pattern()</code>","text":"<p>Enables fnmatch pattern matching.</p> <pre><code>&lt;?php\n$blog = (new Component(...))\n   -&gt;route('/blog/*', '/articles/*')\n   -&gt;pattern();\n</code></pre> Pattern Matches <code>/blog/*</code> <code>/blog/my-post</code>, <code>/blog/123</code> <code>/user/*/posts/*</code> <code>/user/123/posts/456</code> <p>Extracting Values from Patterns</p> <p>Pattern matching only validates routes. To extract values, use the <code>Request</code> object:</p> <pre><code>&lt;?php\nuse PhpSPA\\Component;\nuse PhpSPA\\Http\\Request;\n\n$blog = (new Component(function(Request $request) {\n    $uri = $request-&gt;getUri();\n    preg_match('/\\/blog\\/(.+)/', $uri, $matches);\n    $slug = $matches[1] ?? null;\n\n    return \"&lt;article&gt;Post: {$slug}&lt;/article&gt;\";\n}))\n   -&gt;route('/blog/*')\n   -&gt;pattern();\n</code></pre>"},{"location":"references/preloading-component/#methodstring-methods","title":"<code>method(string ...$methods)</code>","text":"<p>Accepts multiple HTTP methods.</p> <pre><code>&lt;?php\n$form = (new Component(...))-&gt;method('GET', 'POST', 'PUT');\n</code></pre>"},{"location":"references/preloading-component/#routestring-routes","title":"<code>route(string ...$routes)</code>","text":"<p>Defines multiple routes to same component.</p> <pre><code>&lt;?php\n$contact = (new Component(...))\n   -&gt;route('/contact', '/contact-us', '/get-in-touch');\n</code></pre>"},{"location":"references/preloading-component/#more-examples","title":"\ud83c\udfa8 More Examples","text":""},{"location":"references/preloading-component/#multi-section-dashboard","title":"Multi-Section Dashboard","text":"<pre><code>&lt;?php\n$navbar = (new Component(...))-&gt;name('navbar')-&gt;targetID('navbar');\n$sidebar = (new Component(...))-&gt;name('sidebar')-&gt;targetID('sidebar');\n\n$dashboard = (new Component(...))\n   -&gt;route('/dashboard')\n   -&gt;targetID('content')\n   -&gt;preload('navbar', 'sidebar');\n\n$settings = (new Component(...))\n   -&gt;route('/dashboard/settings')\n   -&gt;targetID('content')\n   -&gt;preload('navbar', 'sidebar');\n</code></pre>"},{"location":"references/preloading-component/#email-client","title":"Email Client","text":"<pre><code>&lt;?php\n$folders = (new Component(...))-&gt;name('folders')-&gt;targetID('folders');\n$emailList = (new Component(...))-&gt;name('emailList')-&gt;targetID('emailList');\n\n$emailViewer = (new Component(function(array $path) {\n   return \"&lt;section&gt;Email #{$path['id']}&lt;/section&gt;\";\n}))\n   -&gt;route('/email/{id: int}')\n   -&gt;targetID('emailViewer')\n   -&gt;preload('folders', 'emailList')\n   -&gt;exact();\n</code></pre>"},{"location":"references/preloading-component/#common-pitfalls","title":"\u26a0\ufe0f Common Pitfalls","text":""},{"location":"references/preloading-component/#same-targetid-for-multiple-components","title":"\u274c Same <code>targetID</code> for Multiple Components","text":"<pre><code>&lt;?php\n$c1 = (new Component(...))-&gt;targetID('app');\n$c2 = (new Component(...))-&gt;targetID('app'); // Replaces c1!\n</code></pre> <p>Solution: Use different target IDs.</p>"},{"location":"references/preloading-component/#forgetting-name-for-preload","title":"\u274c Forgetting <code>name()</code> for Preload","text":"<pre><code>&lt;?php\n$sidebar = (new Component(...))-&gt;targetID('sidebar');\n$main = (new Component(...))-&gt;preload('sidebar'); // ERROR!\n</code></pre> <p>Solution: Set <code>name('sidebar')</code>.</p>"},{"location":"references/preloading-component/#not-using-exact-for-dynamic-content","title":"\u274c Not Using <code>exact()</code> for Dynamic Content","text":"<p>Without <code>exact()</code>, navigating away leaves stale content visible.</p>"},{"location":"references/preloading-component/#related-documentation","title":"\ud83d\udcda Related Documentation","text":"<p> Component Basics  Advanced Routing  State Management</p> <p>Need help?  Open an issue</p>"},{"location":"references/response/","title":"Response API Reference","text":"<p>The <code>Response</code> class provides a fluent interface for HTTP response management in PhpSPA. It combines powerful helper methods with chainable modifiers to make API development robust and expressive.</p> <p>Namespace</p> <p><code>PhpSPA\\Http\\Response</code></p>"},{"location":"references/response/#basic-usage","title":"Basic Usage","text":""},{"location":"references/response/#quick-json-response","title":"Quick JSON Response","text":"<pre><code>&lt;?php\n\nuse PhpSPA\\Http\\Response;\n\n// Send an immediate JSON response\nResponse::sendSuccess(['id' =&gt; 1], 'User created');\n</code></pre>"},{"location":"references/response/#fluent-chain-construction","title":"Fluent Chain Construction","text":"<pre><code>&lt;?php\n\nreturn (new Response())\n    -&gt;status(200)\n    -&gt;header('X-Custom-Header', 'AppValue')\n    -&gt;data(['message' =&gt; 'Hello World']);\n</code></pre>"},{"location":"references/response/#response-types","title":"Response Types","text":"<p>The <code>Response</code> class includes dedicated methods for common HTTP scenarios.</p>"},{"location":"references/response/#success-responses","title":"Success Responses","text":"Method Status Description <code>success($data, $message)</code> <code>200</code> Standard success response <code>created($data, $message)</code> <code>201</code> Resource successfully created <code>sendFile($path)</code> <code>200</code> Streams a file with auto-compression <p>Example: <pre><code>&lt;?php\n\n// Standard success\nreturn $response-&gt;success($user, 'User profile retrieved');\n\n// File download with compression support\nreturn $response-&gt;sendFile('/storage/reports/2024.pdf');\n</code></pre></p>"},{"location":"references/response/#error-responses","title":"Error Responses","text":"Method Status Description <code>error($msg, $details)</code> <code>---</code> Generic error wrapper <code>notFound($msg)</code> <code>404</code> Resource not found <code>unauthorized($msg)</code> <code>401</code> Authentication required <code>forbidden($msg)</code> <code>403</code> Access denied <code>validationError($errors)</code> <code>422</code> Form validation failure <p>Example: <pre><code>&lt;?php\n\nif (!$user) {\n    return $response-&gt;notFound('User does not exist');\n}\n\nif ($input-&gt;fails()) {\n    return $response-&gt;validationError($input-&gt;errors());\n}\n</code></pre></p>"},{"location":"references/response/#special-responses","title":"Special Responses","text":""},{"location":"references/response/#redirects","title":"Redirects","text":"<p>Exit Behavior</p> <p>The <code>redirect()</code> method terminates script execution immediately.</p> <pre><code>&lt;?php\n\n// Redirect to another URL\n$response-&gt;redirect('/login', 302);\n</code></pre>"},{"location":"references/response/#pagination","title":"Pagination","text":"<p>Standardized pagination structure.</p> <pre><code>&lt;?php\n\nreturn $response-&gt;paginate(\n    items: $users, \n    total: 100, \n    perPage: 15, \n    currentPage: 1, \n    lastPage: 7\n);\n</code></pre>"},{"location":"references/response/#modifiers","title":"Modifiers","text":"<p>Customize instances using chainable methods.</p>"},{"location":"references/response/#statusint-code","title":"<code>status(int $code)</code>","text":"<p>Set the HTTP status code. <pre><code>&lt;?php\n\n$response-&gt;status(Response::StatusTeapot); // 418\n</code></pre></p>"},{"location":"references/response/#headerstring-name-string-value","title":"<code>header(string $name, string $value)</code>","text":"<p>Set a single header. <pre><code>&lt;?php\n\n$response-&gt;header('Cache-Control', 'no-cache');\n</code></pre></p>"},{"location":"references/response/#contenttypestring-type","title":"<code>contentType(string $type)</code>","text":"<p>Set the MIME type. <pre><code>&lt;?php\n\n$response-&gt;contentType('application/xml');\n</code></pre></p>"},{"location":"references/response/#static-helpers","title":"Static Helpers","text":"<p>Helpers to send responses immediately without <code>return</code>.</p> <p>Immediate Execution</p> <p>These methods construct the response, send headers, output content, and exit the application.</p> <pre><code>&lt;?php\n\n// Send simple JSON\nResponse::sendJson(['foo' =&gt; 'bar']);\n\n// Send formatted success\nResponse::sendSuccess($data, 'Operation complete');\n\n// Send formatted error\nResponse::sendError('Database connection failed', 500);\n</code></pre>"},{"location":"references/response/#status-constants","title":"Status Constants","text":"<p>Use these constants for readable status codes.</p> Constant Value <code>Response::StatusOK</code> 200 <code>Response::StatusCreated</code> 201 <code>Response::StatusBadRequest</code> 400 <code>Response::StatusUnauthorized</code> 401 <code>Response::StatusForbidden</code> 403 <code>Response::StatusNotFound</code> 404 <code>Response::StatusInternalServerError</code> 500"},{"location":"references/router/","title":"Router &amp; Middleware API Reference","text":"<p>New in v2.0.4</p> <p>The enhanced routing and middleware features described in this document were introduced in PhpSPA v2.0.4.</p> <p>The Router system in PhpSPA provides a powerful way to manage application routes, groups, and middleware. It supports nested prefixes, group-level middleware, and specific route middleware.</p> <p>Namespace</p> <p><code>PhpSPA\\Http\\Router</code></p>"},{"location":"references/router/#route-grouping","title":"Route Grouping","text":"<p>Grouping routes allows you to share common URI prefixes and middleware across a set of routes.</p>"},{"location":"references/router/#app-level-prefixing","title":"App Level Prefixing","text":"<p>Use the <code>App::prefix</code> method to define a top-level group in your application entry point.</p> <pre><code>&lt;?php\n\n$app-&gt;prefix('/api', function (Router $router) {\n    // Routes defined here will be prefixed with /api\n    $router-&gt;get('/users', function ($req, $res) {\n        return $res-&gt;success(['user1', 'user2']);\n    });\n});\n</code></pre> Method Description <code>prefix(string $path, callable $handler)</code> Registers a route group behavior. The <code>$handler</code> receives a <code>Router</code> instance."},{"location":"references/router/#nested-prefixes","title":"Nested Prefixes","text":"<p>Inside a route group, you can further nest routes using <code>$router-&gt;prefix</code>.</p> <pre><code>&lt;?php\n\n$app-&gt;prefix('/api', function (Router $router) {\n\n    // Creates /api/v1\n    $router-&gt;prefix('/v1', function (Router $router) {\n\n        // Matches GET /api/v1/status\n        $router-&gt;get('/status', fn($req, $res) =&gt; $res-&gt;success('API V1 Online'));\n\n    });\n\n});\n</code></pre>"},{"location":"references/router/#middleware","title":"Middleware","text":"<p>Middleware provide a convenient mechanism for inspecting and filtering HTTP requests entering your application.</p>"},{"location":"references/router/#middleware-signature","title":"Middleware Signature","text":"<p>Middleware closures receive three arguments:</p> <ol> <li><code>Request $request</code>: The HTTP request object.</li> <li><code>Response $response</code>: The Response factory.</li> <li><code>Closure $next</code>: The callback to pass control to the next middleware.</li> </ol> <pre><code>&lt;?php\n\nfunction (Request $req, Response $res, Closure $next) {\n    if (!valid()) {\n        return $res-&gt;unauthorized('Access Denied');\n    }\n    return $next();\n};\n</code></pre>"},{"location":"references/router/#group-middleware","title":"Group Middleware","text":"<p>You can apply middleware to a whole group of routes using <code>$router-&gt;middleware()</code>. This middleware runs for every route defined within the group (and sub-groups).</p> <pre><code>&lt;?php\n\n$app-&gt;prefix('/admin', function (Router $router) {\n\n    // Apply authentication middleware to all /admin routes\n    $router-&gt;middleware(function ($req, $res, $next) {\n        if (!$req-&gt;session('user_id')) {\n            return $res-&gt;redirect('/login');\n        }\n        return $next();\n    });\n\n    $router-&gt;get('/dashboard', ...);\n    $router-&gt;get('/settings', ...);\n\n});\n</code></pre>"},{"location":"references/router/#route-specific-middleware","title":"Route Specific Middleware","text":"<p>You can assign middleware to specific routes by passing additional callables before the final handler.</p> <pre><code>&lt;?php\n\n$checkRole = function ($req, $res, $next) {\n    // Custom logic\n    return $next();\n};\n\n$router-&gt;get('/users/{id}', $checkRole, function ($req, $res) {\n    return $res-&gt;success('User Data');\n});\n</code></pre>"},{"location":"references/router/#static-files","title":"Static Files","text":"<p>Serve static files directly without manual route definitions using <code>App::useStatic</code>.</p> <pre><code>&lt;?php\n\n// Maps http://example.com/assets -&gt; /var/www/public/assets\n$app-&gt;useStatic('/assets', __DIR__ . '/../public/assets');\n</code></pre> Method Description <code>useStatic(string $route, string $path)</code> Maps a URL route to a filesystem directory or file."},{"location":"references/router/#api-methods","title":"API Methods","text":"<p>The <code>Router</code> instance supports standard HTTP verbs.</p> Method Description <code>get($route, ...$handlers)</code> Register a GET route <code>post($route, ...$handlers)</code> Register a POST route <code>put($route, ...$handlers)</code> Register a PUT route <code>patch($route, ...$handlers)</code> Register a PATCH route <code>delete($route, ...$handlers)</code> Register a DELETE route <code>head($route, ...$handlers)</code> Register a HEAD route <p>Example: <pre><code>&lt;?php\n\n$router-&gt;post('/users', $validatorMiddleware, function ($req, $res) {\n    return $res-&gt;created(null, 'User created');\n});\n</code></pre></p>"},{"location":"references/helpers/fmt/","title":"<code>fmt()</code> Helper","text":"<ul> <li> <p> Type Preservation</p> <p>Pass any data type between components with perfect type safety</p> </li> <li> <p> Zero Configuration</p> <p>Works automatically with classes, arrays, objects, and primitives</p> </li> <li> <p> Auto Serialization</p> <p>Automatic encoding and decoding behind the scenes</p> </li> <li> <p> Type Safe</p> <p>Maintains exact type signatures across component boundaries</p> </li> </ul> <p>New in v2.0.1</p> <p> Enhanced type preservation for component props</p>"},{"location":"references/helpers/fmt/#quick-start","title":"Quick Start","text":"<pre><code>&lt;?php\nclass User {\n    public function __construct(\n        public string $name,\n        public int $age\n    ) {}\n}\n\n$user = new User('John Doe', 25);\nfmt($user);\n\n// Pass to component - receives exact User instance!\nreturn \"&lt;UserProfile&gt;{$user}&lt;/UserProfile&gt;\";\n</code></pre> <pre><code>&lt;?php\nfunction UserProfile(User $children) {\n    // Type-safe - receives actual User instance\n    return &lt;&lt;&lt;HTML\n        &lt;div&gt;\n            &lt;h2&gt;{$children-&gt;name}&lt;/h2&gt;\n            &lt;p&gt;Age: {$children-&gt;age}&lt;/p&gt;\n        &lt;/div&gt;\n    HTML;\n}\n</code></pre>"},{"location":"references/helpers/fmt/#multiple-arguments","title":"Multiple Arguments","text":"<pre><code>&lt;?php\n$product = new Product('iPhone', 999.99);\n$options = ['badge' =&gt; 'New'];\n$theme = 'dark';\n\nfmt($product, $options, $theme);\n\nreturn \"&lt;ProductCard theme='{$theme}' options='{$options}'&gt;{$product}&lt;/ProductCard&gt;\";\n</code></pre>"},{"location":"references/helpers/fmt/#what-it-does","title":"What It Does","text":"<p><code>fmt()</code> preserves exact data types when passing props between components:</p> <ul> <li>\u2705 Custom classes remain their original type</li> <li>\u2705 Arrays, objects, strings, numbers all preserved</li> <li>\u2705 Works with interfaces, readonly properties, enums</li> <li>\u2705 Automatic serialization/deserialization</li> </ul> <p>Component Tags Only</p> <p>Only works with component tag syntax: <code>&lt;Component&gt;{$data}&lt;/Component&gt;</code></p>"},{"location":"references/hooks/use-fetch/","title":"<code>useFetch</code> API","text":"<p>New in v2.0.1</p> <p> Async HTTP requests with parallel execution support</p> <ul> <li> <p> Simple &amp; Powerful</p> <p>Fluent interface for HTTP requests with full async support</p> </li> <li> <p> Highly Configurable</p> <p>Timeouts, SSL, headers, redirects - everything you need</p> </li> <li> <p> Parallel Execution</p> <p>True concurrent requests with curl_multi for maximum performance</p> </li> <li> <p> Modern PHP API</p> <p>Familiar syntax with modern PHP features</p> </li> </ul> <p>Namespace</p> <pre><code>&lt;?php\nuse function Component\\useFetch;\n</code></pre>"},{"location":"references/hooks/use-fetch/#basic-usage","title":"Basic Usage","text":""},{"location":"references/hooks/use-fetch/#simple-get-request","title":"Simple GET Request","text":"Direct UsageArray AccessWith Parameters <pre><code>&lt;?php\n// Auto-executes and returns decoded JSON\necho useFetch('https://api.example.com/users/1');\n</code></pre> <pre><code>&lt;?php\n$user = useFetch('https://api.example.com/users/1');\necho $user['data']['first_name'];\n</code></pre> <pre><code>&lt;?php\n$response = useFetch('https://api.example.com/users')\n    -&gt;get(['page' =&gt; 2, 'limit' =&gt; 10]);\n</code></pre>"},{"location":"references/hooks/use-fetch/#http-methods","title":"HTTP Methods","text":"POSTPUTPATCHDELETE <pre><code>&lt;?php\nuseFetch('https://api.example.com/users')\n    -&gt;post(['name' =&gt; 'Dave', 'job' =&gt; 'Developer']);\n</code></pre> <pre><code>&lt;?php\nuseFetch('https://api.example.com/users/2')\n    -&gt;put(['job' =&gt; 'Senior Developer']);\n</code></pre> <pre><code>&lt;?php\nuseFetch('https://api.example.com/users/2')\n    -&gt;patch(['job' =&gt; 'Lead Developer']);\n</code></pre> <pre><code>&lt;?php\nuseFetch('https://api.example.com/users/2')\n    -&gt;delete(['force' =&gt; 'true']);\n</code></pre>"},{"location":"references/hooks/use-fetch/#configuration-options","title":"Configuration Options","text":"<p>Chain Before HTTP Method</p> <p>All configuration methods must be called before <code>-&gt;get()</code>, <code>-&gt;post()</code>, etc.</p> <pre><code>&lt;?php\n$response = useFetch('https://api.example.com/users')\n    -&gt;headers(['Authorization' =&gt; 'Bearer token']) // (1)\n    -&gt;timeout(30)              // (2)\n    -&gt;connectTimeout(5)        // (3)\n    -&gt;verifySSL(true)          // (4)\n    -&gt;withCertificate('/path/to/cacert.pem') // (5)\n    -&gt;followRedirects(true, 5) // (6)\n    -&gt;withUserAgent('MyApp/1.0') // (7)\n    -&gt;get();\n</code></pre> <ol> <li> Headers - Add custom headers (Authorization, API keys, etc.)</li> <li> Timeout - Request timeout in seconds (supports decimals like <code>0.5</code>)</li> <li> Connect Timeout - Connection timeout (cURL only)</li> <li> SSL Verification - Enable/disable certificate verification</li> <li> CA Bundle - Path to custom certificate bundle</li> <li> Redirects - Follow redirects with max limit (cURL only)</li> <li> User Agent - Custom User-Agent string</li> </ol>"},{"location":"references/hooks/use-fetch/#response-handling","title":"Response Handling","text":"<pre><code>&lt;?php\n$response = useFetch('https://api.example.com/users/2')-&gt;get();\n\n$data = $response-&gt;json();      // (1)\n$text = $response-&gt;text();      // (2)\n$status = $response-&gt;status();  // (3)\n$headers = $response-&gt;headers(); // (4)\n\nif ($response-&gt;ok()) {          // (5)\n    // Success handling\n}\n\nif ($response-&gt;failed()) {      // (6)\n    echo $response-&gt;error();    // (7)\n}\n</code></pre> <ol> <li> Returns decoded JSON as associative array</li> <li> Returns raw response body as string</li> <li> Returns HTTP status code (200, 404, etc.)</li> <li> Returns response headers as array</li> <li> Checks if status is 200-299</li> <li> Checks if request failed</li> <li> Returns error message string</li> </ol>"},{"location":"references/hooks/use-fetch/#asynchronous-requests","title":"Asynchronous Requests","text":"<p>Requires cURL Extension</p> <p>Async features only work when cURL is available. Falls back to sync execution otherwise.</p>"},{"location":"references/hooks/use-fetch/#single-async-request","title":"Single Async Request","text":"<pre><code>&lt;?php\n$promise = useFetch('https://api.example.com/users/1')-&gt;async()-&gt;get();\n\n// Do other work here...\n\n$response = $promise-&gt;wait();\necho $response-&gt;json()['name'];\n</code></pre>"},{"location":"references/hooks/use-fetch/#parallel-execution-recommended","title":"Parallel Execution (Recommended)","text":"<p>True Concurrency</p> <p>Execute multiple requests simultaneously using <code>curl_multi</code> for maximum performance!</p> Parallel (Fast)Sequential (Slow) <pre><code>&lt;?php\nuse PhpSPA\\Core\\Client\\AsyncResponse;\n\n// Prepare requests\n$user = useFetch('https://api.example.com/users/1')-&gt;async()-&gt;get();\n$posts = useFetch('https://api.example.com/posts')-&gt;async()-&gt;get(['userId' =&gt; 1]);\n$comments = useFetch('https://api.example.com/comments')-&gt;async()-&gt;get(['userId' =&gt; 1]);\n\n// Execute all simultaneously\n[$userRes, $postsRes, $commentsRes] = AsyncResponse::all([\n    $user, $posts, $comments\n]);\n\necho $userRes-&gt;json()['name'];\necho count($postsRes-&gt;json()) . \" posts\";\n</code></pre> <pre><code>&lt;?php\n// Without AsyncResponse::all() - executes one by one\n$user = $userPromise-&gt;wait()-&gt;json();\n$posts = $postsPromise-&gt;wait()-&gt;json();\n$comments = $commentsPromise-&gt;wait()-&gt;json();\n</code></pre>"},{"location":"references/hooks/use-fetch/#with-callbacks","title":"With Callbacks","text":"<pre><code>&lt;?php\nuseFetch('https://api.example.com/users/1')\n    -&gt;async()\n    -&gt;get()\n    -&gt;then(fn($res) =&gt; print $res-&gt;json()['name'])\n    -&gt;wait();\n</code></pre>"},{"location":"references/hooks/use-fetch/#complete-examples","title":"Complete Examples","text":""},{"location":"references/hooks/use-fetch/#post-with-error-handling","title":"POST with Error Handling","text":"<pre><code>&lt;?php\n$response = useFetch('https://api.example.com/users')\n    -&gt;headers(['Authorization' =&gt; 'Bearer token'])\n    -&gt;timeout(15)\n    -&gt;post(['name' =&gt; 'Dave', 'email' =&gt; 'dave@example.com']);\n\nif ($response-&gt;ok()) {\n    echo \"\u2705 User created: \" . $response-&gt;json()['id'];\n} else {\n    error_log('\u274c API Error: ' . $response-&gt;error());\n}\n</code></pre>"},{"location":"references/hooks/use-fetch/#parallel-api-calls","title":"Parallel API Calls","text":"<pre><code>&lt;?php\nuse PhpSPA\\Core\\Client\\AsyncResponse;\n\n$requests = [\n    useFetch('https://api.example.com/users/1')-&gt;async()-&gt;get(),\n    useFetch('https://api.example.com/users/2')-&gt;async()-&gt;get(),\n    useFetch('https://api.example.com/users/3')-&gt;async()-&gt;get(),\n];\n\n$responses = AsyncResponse::all($requests);\n\nforeach ($responses as $res) {\n    echo $res-&gt;json()['name'] . \"\\n\";\n}\n</code></pre>"},{"location":"references/hooks/use-fetch/#important-notes","title":"Important Notes","text":"<p>Avoid Same-Server Requests</p> <p>Never make HTTP requests to the same server handling the current request - it causes deadlock!</p> <pre><code>&lt;?php\n// \u274c Don't do this\n$response = useFetch('http://localhost:8000/same-app-route')-&gt;get();\n\n// \u2705 Do this instead\n$data = getSomeData();\n</code></pre> <p>Understanding Async Behavior</p> <p>PHP is synchronous by nature. The <code>async()</code> method prepares cURL handles without executing them:</p> <ul> <li>Use <code>AsyncResponse::all()</code> for true parallel execution with <code>curl_multi</code></li> <li>Sequential <code>wait()</code> calls execute requests one by one</li> <li>Parallel execution is significantly faster for multiple requests</li> </ul>"},{"location":"references/hooks/clients/use-callback/","title":"Client-Side <code>useCallback</code>","text":"<p>New in v2.0.5</p> <p> Memoized callbacks keep listener references stable even when PhpSPA re-renders a target.</p> <p>Keep event handlers and other functions stable between renders so you do not attach duplicate listeners every time PhpSPA updates a target. <code>useCallback()</code> memoizes a function until one of its dependencies changes.</p> <pre><code>const memoizedFn = useCallback(fn, dependencies?)\n</code></pre> <ul> <li>fn: The callback you plan to pass to an event listener, child script, or another hook.</li> <li>dependencies: Optional array containing state keys (strings) and/or direct values/objects. PhpSPA resolves each string against its state store and keeps the DOM node reference intact, so the memoized function refreshes whenever the underlying state value changes or one of the direct dependencies gains a new reference.</li> </ul>"},{"location":"references/hooks/clients/use-callback/#when-to-use-it","title":"When to Use It","text":"<ul> <li>Attaching DOM listeners once (e.g., <code>addEventListener</code> / <code>removeEventListener</code>).</li> <li>Passing callbacks to custom elements or scripts that expect a stable reference.</li> <li>Pairing with <code>useEffect()</code> cleanups that depend on referential equality.</li> </ul>"},{"location":"references/hooks/clients/use-callback/#example-toggling-the-docs-navigation","title":"Example: Toggling the Docs Navigation","text":"<pre><code>const toggleNavLinks = () =&gt; {\n   const navToggle = document.querySelector('[data-nav-toggle]')\n   const navLinks = document.querySelector('[data-nav-links]')\n\n   if (!navToggle || !navLinks) return\n\n   const toggle = useCallback(() =&gt; {\n      navLinks.classList.toggle('hidden')\n   }, ['theme', navLinks])\n\n   navToggle.addEventListener('click', toggle)\n}\n</code></pre> <ul> <li><code>'theme'</code> refers to the <code>theme</code> key inside PhpSPA state. When <code>setState('theme', value)</code> runs, the memoized function is recreated.</li> <li><code>navLinks</code> keeps the memoized function tied to the actual DOM node. If the layout swaps out the element, the dependency array detects the new reference and rebinds the handler automatically.</li> </ul>"},{"location":"references/hooks/clients/use-callback/#cleanup-tip","title":"Cleanup Tip","text":"<p>Pair <code>useCallback()</code> with <code>useEffect()</code> when you need to tear down listeners:</p> <pre><code>useEffect(() =&gt; {\n   navToggle.addEventListener('click', toggle)\n   return () =&gt; navToggle.removeEventListener('click', toggle)\n}, [toggle])\n</code></pre> <p>Because <code>toggle</code> stays stable until its dependencies change, the effect can safely remove and reattach the listener without leaking handlers.</p>"},{"location":"references/hooks/clients/use-callback/#full-example-with-usecallback-and-useeffect-cleanup","title":"Full Example with <code>useCallback()</code> and <code>useEffect()</code> cleanup","text":"<pre><code>const toggleNavLinks = () =&gt; {\n   const navToggle = document.querySelector('[data-nav-toggle]')\n   const navLinks = document.querySelector('[data-nav-links]')\n\n   if (!navToggle || !navLinks) return\n\n   const toggle = useCallback(() =&gt; {\n      navLinks.classList.toggle('hidden')\n   }, ['theme', navLinks])\n\n   useEffect(() =&gt; {\n      navToggle.addEventListener('click', toggle)\n      return () =&gt; navToggle.removeEventListener('click', toggle)\n   }, [toggle])\n}\n</code></pre>"},{"location":"references/hooks/clients/use-effect/","title":"Client-Side useEffect \u269b\ufe0f","text":"<p>New in v2.0.4</p> <p> Client-side useEffect hook for side effects in JavaScript component scripts.</p> <p>Manage side effects (like event listeners, timers, or DOM manipulation) and their cleanups in your component scripts.</p>"},{"location":"references/hooks/clients/use-effect/#usage","title":"Usage","text":"<p>The hook accepts a callback function and an optional dependency array.</p> <pre><code>useEffect(callback, dependencies?)\n</code></pre> <ul> <li>callback: Function containing your side effect logic. It can optionally return a cleanup function.</li> <li>dependencies: Array of state keys (strings) or arbitrary values/objects. Strings map to <code>phpspa</code> state keys, while any other value is compared by reference. The effect re-runs when any resolved dependency changes.</li> </ul>"},{"location":"references/hooks/clients/use-effect/#real-world-example","title":"Real-World Example","text":"<pre><code>&lt;script&gt;\n   // Initial state from PHP\n   let currentCount = {$count};\n\n   useEffect(() =&gt; {\n      const btn = document.getElementById('counter-btn');\n\n      const handleClick = async () =&gt; {\n         currentCount++;\n         // Update application state\n         await phpspa.setState('counter', currentCount);\n      };\n\n      btn.addEventListener('click', handleClick);\n\n      // Cleanup: remove listener when component unmounts or effect re-runs\n      return () =&gt; btn.removeEventListener('click', handleClick);\n   }, ['counter']); \n&lt;/script&gt;\n</code></pre> <p>Dependency Control</p> <ul> <li><code>['stateKey']</code>: Effect runs on mount and whenever the <code>stateKey</code> value in PhpSPA state changes.</li> <li><code>['stateKey', navToggle]</code>: Mix state keys with concrete values (DOM nodes, numbers, etc.). PhpSPA compares the resolved values, so the effect re-runs when the state changes or when the direct value reference changes.</li> <li><code>[]</code>: Effect runs only once on mount (perfect for initial setup).</li> <li><code>null</code> (or omitted): Effect runs on every render (usually not recommended).</li> </ul>"},{"location":"references/hooks/clients/use-effect/#mixing-state-and-direct-dependencies","title":"Mixing State and Direct Dependencies","text":"<pre><code>useEffect(() =&gt; {\n   const nav = document.querySelector('[data-nav-links]')\n   if (!nav) return\n\n   const handler = event =&gt; {\n      console.log('theme state is now', phpspaState.theme)\n      nav.classList.toggle('hidden')\n   }\n\n   document.addEventListener('phpspa:theme-toggle', handler)\n   return () =&gt; document.removeEventListener('phpspa:theme-toggle', handler)\n}, ['theme', document.querySelector('[data-nav-links]')])\n</code></pre> <p>The hook tracks the <code>theme</code> state key under the hood and keeps the DOM node reference intact. The effect runs again only when the theme state value changes or when the DOM node reference changes (e.g., the layout is replaced).</p>"},{"location":"requests/","title":"Handling Requests &amp; Sessions","text":"<p>Your components often need to process incoming data, like form submissions or API calls. PhpSPA provides a clean, object-oriented way to access request data.</p> <p>Request Object</p> <p>When a component is rendered, it can receive the current <code>Request</code> object as an argument.</p>"},{"location":"requests/#accessing-request-data","title":"Accessing Request Data","text":"<p>The <code>Request</code> object is a powerful wrapper around PHP's superglobals (<code>$_POST</code>, <code>$_GET</code>, <code>$_FILES</code>, etc.), making your code cleaner and more secure.</p> <p>Here's how you would handle a form submission:</p> <pre><code>&lt;?php\n\nuse PhpSPA\\Component;\nuse PhpSPA\\Http\\Request;\n\n$loginPage = new Component(function (Request $request) {\n   // Check if the form was submitted\n   if ($request-&gt;isMethod('POST')) {\n      $email = $request('email');\n      $password = $request('password');\n\n      // ... process login logic ...\n   }\n\n   // Display the login form\n   echo &lt;&lt;&lt;HTML\n      &lt;form method=\"POST\"&gt;\n         &lt;input type=\"email\" name=\"email\" placeholder=\"Email\"&gt;\n         &lt;input type=\"password\" name=\"password\" placeholder=\"Password\"&gt;\n         &lt;button type=\"submit\"&gt;Log In&lt;/button&gt;\n      &lt;/form&gt;\n   HTML;\n});\n\n$loginPage-&gt;route('/login')-&gt;method('GET|POST');\n</code></pre> <p>Request Methods</p> <p>The <code>Request</code> object has many other useful methods:</p> <ul> <li><code>$request-&gt;get('key')</code>: Get a URL query parameter</li> <li><code>$request-&gt;json('key')</code>: Get data from a JSON request body</li> <li><code>$request-&gt;files('avatar')</code>: Access uploaded file data</li> <li><code>$request-&gt;header('Authorization')</code>: Read a request header</li> <li><code>$request-&gt;ip()</code>: Get the client's IP address</li> <li><code>$request-&gt;isAjax()</code>: Check if it's an AJAX request</li> </ul>"},{"location":"requests/#redirects-session-management","title":"Redirects &amp; Session Management","text":"<p><code>PhpSPA</code> also includes helpers for common actions.</p> RedirectingSessions <p>Use the global <code>Redirect()</code> function to send the user to a new page.</p> <pre><code>&lt;?php\n\nuse function PhpSPA\\Http\\Redirect;\n\nRedirect('/dashboard');\n</code></pre> <p>Use the static <code>Session</code> class to manage user data across requests.</p> <pre><code>&lt;?php\n\nuse PhpSPA\\Http\\Session;\n\nSession::set('user_id', 123);\n$userId = Session::get('user_id');\n</code></pre> <p>Login Handler</p> <pre><code>&lt;?php\n\nuse PhpSPA\\Http\\Request;\nuse PhpSPA\\Http\\Session;\nuse function PhpSPA\\Http\\Redirect;\n\nfunction handleLogin(Request $request) {\n   $email = $request-&gt;post('email');\n   // ... validate user ...\n\n   if ($isValid) {\n      Session::set('user_id', 123); // Log the user in\n      Redirect('/dashboard');      // Send them to the dashboard\n   }\n}\n</code></pre>"},{"location":"requests/#content-security-policy-csp","title":"Content Security Policy (CSP)","text":"<p>For added security, you can easily enable a nonce-based Content Security Policy to protect against XSS attacks.</p> <pre><code>&lt;?php\nuse PhpSPA\\Http\\Security\\Nonce;\n\n// Enable CSP with a strict policy\nNonce::enable();\n\n$nonce = Nonce::attr();\n\n// In your layout, use the nonce attribute for your scripts\necho &lt;&lt;&lt;HTML\n   &lt;script $nonce&gt;\n      /* ... */\n   &lt;/script&gt;\nHTML;\n</code></pre> <p>Security Best Practice</p> <p>The nonce attribute ensures only authorized inline scripts can execute, protecting against XSS attacks.</p>"},{"location":"requests/api-authentication/","title":"API Authentication","text":"<p>PhpSPA isn't just for rendering HTML. You can easily create secure API endpoints by creating components that return JSON. The <code>Request</code> object has built-in helpers to make checking for authentication credentials simple and clean.</p> <p>Secure APIs</p> <p>This is perfect for when your frontend needs to fetch data from a secure source.</p>"},{"location":"requests/api-authentication/#api-key-authentication","title":"API Key Authentication","text":"<p>A common method for securing an API is to require an API key in the request headers. The <code>$request-&gt;apiKey()</code> method makes this easy to check.</p> <p>By default, it looks for the key in the <code>Api-Key</code> header.</p> <pre><code>&lt;?php\nuse PhpSPA\\Component;\nuse PhpSPA\\Http\\Request;\n\n$userDataApi = new Component(function (Request $request) {\n   // 1. Validate the API key.\n   // Replace 'YOUR_SECRET_KEY' with your actual key.\n   if (!$request-&gt;apiKey('YOUR_SECRET_KEY')) {\n      http_response_code(401); // Unauthorized\n      header('Content-Type: application/json');\n      echo json_encode(['error' =&gt; 'Invalid API Key']);\n      return;\n   }\n\n   // 2. If the key is valid, return the data.\n   $data = ['id' =&gt; 123, 'name' =&gt; 'John Doe', 'email' =&gt; 'john.doe@example.com'];\n   header('Content-Type: application/json');\n   return json_encode($data);\n});\n\n$userDataApi-&gt;route('/api/user');\n</code></pre> <p>Default Header</p> <p>By default, it looks for the key in the <code>Api-Key</code> header.</p>"},{"location":"requests/api-authentication/#http-basic-bearer-token-authentication","title":"HTTP Basic &amp; Bearer Token Authentication","text":"<p>For more standard authentication methods, the <code>$request-&gt;auth()</code> method is your go-to tool. It automatically parses the <code>Authorization</code> header and gives you access to both Basic and Bearer token credentials.</p> <pre><code>&lt;?php\nuse PhpSPA\\Component;\nuse PhpSPA\\Http\\Request;\n\n$secureDataApi = new Component(function (Request $request) {\n   $auth = $request-&gt;auth();\n\n   // Check for a Bearer token (commonly used with JWTs)\n   if ($auth-&gt;bearer) {\n      // ... validate the Bearer token ...\n      if (isValidToken($auth-&gt;bearer)) {\n         echo json_encode(['data' =&gt; 'This is your secure data.']);\n         return;\n      }\n   }\n\n   // Check for Basic auth credentials\n   if ($auth-&gt;basic) {\n      // $auth-&gt;basic is an object with 'user' and 'password' properties\n      if ($auth-&gt;basic-&gt;user === 'admin' &amp;&amp; $auth-&gt;basic-&gt;password === 'secret') {\n         echo json_encode(['data' =&gt; 'Authenticated via Basic Auth.']);\n         return;\n      }\n   }\n\n   // If no valid auth is found, deny access.\n   http_response_code(401);\n   echo json_encode(['error' =&gt; 'Authentication required.']);\n});\n\n$secureDataApi-&gt;route('/api/secure-data');\n</code></pre> <p>Authentication Methods</p> <p>Support both Bearer tokens (commonly used with JWTs) and HTTP Basic authentication with a single method.</p>"},{"location":"requests/auto-reloading-components/","title":"Auto-Reloading Components \ud83d\udd04","text":"<p>For components that display live, frequently changing data\u2014like a news ticker, a dashboard chart, or a notification feed\u2014you can instruct PhpSPA to automatically refresh them at a set interval.</p> <p>Efficient Updates</p> <p>This is done by chaining the <code>-&gt;reload()</code> method to your component. This method is highly efficient, as it only re-fetches and updates the specific component, not the entire page.</p>"},{"location":"requests/auto-reloading-components/#how-to-use-it","title":"How to Use It","text":"<p>The <code>-&gt;reload()</code> method accepts one argument: the refresh interval in milliseconds.</p> <p>Here is an example of a live clock component that updates itself every second.</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\nuse PhpSPA\\Component;\n\n// Assume our app and layout are set up\n$app = new App($layout);\n\n// --- Live Clock Component ---\n$liveClock = new Component(function () {\n   // This PHP code runs on the server every time the component is fetched\n   $currentTime = date('H:i:s');\n   return \"&lt;h2&gt;Current Server Time: {$currentTime}&lt;/h2&gt;\";\n});\n\n// Configure the component to reload every 1000 milliseconds (1 second)\n$liveClock\n   -&gt;route('/clock')\n   -&gt;title('Live Clock')\n   -&gt;reload(1000);\n\n// Attach the component\n$app-&gt;attach($liveClock);\n\n$app-&gt;run();\n</code></pre> <p>Live Clock Example</p> <p>Here is an example of a live clock component that updates itself every second.</p> <p>Automatic Updates</p> <p>When a user visits the <code>/clock</code> page, PhpSPA's JavaScript runtime will see the reload instruction and automatically request a fresh version of the <code>liveClock</code> component every second, keeping the time perfectly up-to-date without any full page reloads.</p>"},{"location":"requests/client-side-events-and-api/","title":"Client-Side Events &amp; API","text":"<p>PhpSPA provides a powerful client-side API to hook into the navigation lifecycle and control the application's behavior directly from your JavaScript. This is essential for creating features like loading indicators, animations, and handling navigation errors.</p> <p>Event System</p> <p>Hook into navigation events to create loading indicators, animations, and error handling.</p>"},{"location":"requests/client-side-events-and-api/#listening-to-navigation-events","title":"Listening to Navigation Events","text":"<p>You can listen to navigation events using <code>phpspa.on()</code>. This is perfect for showing or hiding a loading spinner.</p> beforeloadload <p>This event fires before a new page request is made. It receives the destination <code>route</code> as an argument.</p> <pre><code>phpspa.on('beforeload', ({ route }) =&gt; {\n   console.log(`Navigating to: ${route}`);\n   // Show your loading spinner here\n   document.getElementById('loader').style.display = 'block';\n});\n</code></pre> <p>This event fires after a page request completes, whether it was successful or not.</p> <ul> <li>On Success: <code>{ route, success: true, error: false }</code></li> <li>On Failure: <code>{ route, success: false, error: 'Error message', data?: ... }</code></li> </ul> <pre><code>phpspa.on('load', ({ route, success, error, data }) =&gt; {\n   // Hide your loading spinner here\n   document.getElementById('loader').style.display = 'none';\n\n   if (!success) {\n      console.error(`Failed to load route: ${route}`, error);\n      // You could show an error message to the user here\n   }\n});\n</code></pre> <p>Loading States</p> <p>Combine <code>beforeload</code> and <code>load</code> events to create smooth loading transitions.</p>"},{"location":"requests/client-side-events-and-api/#client-side-api-functions","title":"Client-Side API Functions","text":"<p>The PhpSPA object also provides several utility functions to control your application.</p> <ul> <li> <p> Navigation Control</p> <p><code>phpspa.back()</code> &amp; <code>phpspa.forward()</code></p> <p>Navigate backward or forward in the browser's session history.</p> </li> <li> <p> Page Reload</p> <p><code>phpspa.reload()</code></p> <p>Performs a \"soft\" reload of the current page by re-fetching the component's content without a full browser refresh.</p> </li> <li> <p> Component Refresh</p> <p><code>phpspa.reloadComponent()</code></p> <p>A more granular reload that only refreshes the content of the currently active component. This is useful for live data updates.</p> </li> <li> <p> State Management</p> <p><code>phpspa.setState(key, value)</code></p> <p>The same as the global <code>setState()</code> function. It updates a state variable and returns a promise that resolves when the re-render is complete.</p> </li> </ul> <p>State Promise</p> <p>State Promise</p> <pre><code>setState('counter', 5).then(() =&gt; {\n   console.log('Counter has been updated and the component has re-rendered!');\n});\n</code></pre>"},{"location":"requests/request-object/","title":"The Request Object: In-Depth","text":"<p>The <code>Request</code> object is your primary tool for interacting with incoming data. Beyond the basic methods like <code>post()</code> and <code>get()</code>, it offers several powerful shortcuts and helpers to make your code more concise and readable.</p> <p>Universal Access</p> <p>The Request object provides unified access to all types of input data.</p>"},{"location":"requests/request-object/#universal-parameter-access","title":"Universal Parameter Access","text":"<p>Instead of checking <code>post()</code>, <code>get()</code>, and <code>json()</code> separately, you can use the <code>Request</code> object like a function to get a parameter from any input source (<code>$_REQUEST</code>). This is the quickest way to access data.</p> <pre><code>&lt;?php\nuse PhpSPA\\Http\\Request;\n\nfunction SearchHandler(Request $request) {\n   // This will get the 'term' value whether it comes from\n   // a GET query string (?term=...) or a POST form field.\n   $searchTerm = $request('term');\n\n   // ... perform search logic ...\n   return \"&lt;p&gt;Showing results for: &lt;strong&gt;{$searchTerm}&lt;/strong&gt;&lt;/p&gt;\";\n}\n</code></pre> <p>Flexible Input</p> <p>This will get the 'term' value whether it comes from a GET query string (?term=...) or a POST form field.</p>"},{"location":"requests/request-object/#handling-file-uploads","title":"Handling File Uploads","text":"<p>Accessing uploaded files is simple with the <code>-&gt;files()</code> method.</p> All FilesSpecific File <p>Calling <code>$request-&gt;files()</code> with no arguments returns an array of all uploaded files.</p> <pre><code>&lt;?php\n\n$allFiles = $request-&gt;files();\n</code></pre> <p>Calling it with a name returns the data for that specific file input.</p> <pre><code>&lt;?php\n\n$avatarFile = $request-&gt;files('avatar');\n</code></pre> <p>File Upload Handler</p> <pre><code>&lt;?php\n\nuse PhpSPA\\Http\\Request;\n\nfunction ProfileUpload(Request $request) {\n   if ($request-&gt;isMethod('POST')) {\n      $avatarFile = $request-&gt;files('avatar');\n\n      if ($avatarFile &amp;&amp; $avatarFile['error'] === UPLOAD_ERR_OK) {\n         // A file was successfully uploaded\n         $tmpName = $avatarFile['tmp_name'];\n         $fileName = basename($avatarFile['name']);\n         move_uploaded_file($tmpName, \"uploads/{$fileName}\");\n\n         return \"&lt;p&gt;File uploaded successfully!&lt;/p&gt;\";\n      }\n   }\n\n   return &lt;&lt;&lt;HTML\n      &lt;form method=\"POST\" enctype=\"multipart/form-data\"&gt;\n         &lt;input type=\"file\" name=\"avatar\"&gt;\n         &lt;button type=\"submit\"&gt;Upload&lt;/button&gt;\n      &lt;/form&gt;\n   HTML;\n}\n</code></pre> <p>Secure Upload</p> <p>Always validate file uploads on the server-side before processing them.</p>"},{"location":"routing/","title":"Defining Routes","text":"<p> Routing is how you tell PhpSPA which component to show for a specific URL. This is done with the <code>-&gt;route()</code> method. </p> <p>Route Assignment</p> <p>You create a component for each page of your site and assign it a unique URL path.</p>"},{"location":"routing/#route-syntax","title":"Route Syntax","text":"<pre><code>&lt;?php\n\n$component-&gt;route('/path');\n</code></pre> <p>The <code>route()</code> method maps a URL path to a component. Use <code>/</code> for the home page, <code>/about</code> for an about page, etc.</p>"},{"location":"routing/#example","title":"Example","text":"<p>Simple Website</p> <p>Let's create a simple website with a home page and an about page.</p> <p>1. Setup App</p> <pre><code>&lt;?php\n\n$layout = require __DIR__ . '/layout.php';\n$app = new App($layout);\n</code></pre> <p>Load your layout and create the app instance.</p> <p>2. Create Home Page</p> <pre><code>&lt;?php\n\n$homePage = new Component(function () {\n   echo '&lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;';\n});\n$homePage-&gt;route('/');\n</code></pre> <p>Define the home page component and map it to <code>/</code>.</p> <p>3. Create About Page</p> <pre><code>&lt;?php\n\n$aboutPage = new Component(function () {\n   echo '&lt;h1&gt;About Our Company&lt;/h1&gt;';\n});\n$aboutPage-&gt;route('/about');\n</code></pre> <p>Define the about page component and map it to <code>/about</code>.</p> <p>4. Attach and Run</p> <pre><code>&lt;?php\n\n$app-&gt;attach($homePage);\n$app-&gt;attach($aboutPage);\n$app-&gt;run();\n</code></pre> <p>Register components and render the app.</p>"},{"location":"routing/#complete-example","title":"Complete Example","text":"<pre><code>&lt;?php\n\nuse PhpSPA\\App;\nuse PhpSPA\\Component;\n\n// Assume our layout is loaded\n$layout = require __DIR__ . '/layout.php';\n$app = new App($layout);\n\n// --- Create the Home Page Component ---\n$homePage = new Component(function () {\n   echo '&lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;';\n});\n$homePage-&gt;route('/'); // Maps this component to the root URL\n\n// --- Create the About Page Component ---\n$aboutPage = new Component(function () {\n   echo '&lt;h1&gt;About Our Company&lt;/h1&gt;';\n});\n$aboutPage-&gt;route('/about'); // Maps this component to the /about URL\n\n// Attach both components to the app\n$app-&gt;attach($homePage);\n$app-&gt;attach($aboutPage);\n\n// The router will now render the correct component\n$app-&gt;run();\n</code></pre> <p>That's it</p> <p>When a user visits your site at <code>/about</code>, PhpSPA will automatically render the <code>$aboutPage</code> component.</p>"},{"location":"routing/advanced-routing/","title":"Advanced Routing","text":"<p> PhpSPA's router is more than just static paths. It provides a powerful set of features for handling dynamic URLs, multiple routes, and specific HTTP methods, giving you full control over how your application responds to requests. </p>"},{"location":"routing/advanced-routing/#handling-url-parameters","title":"Handling URL Parameters","text":"<p>Dynamic Segments</p> <p>To capture dynamic segments from a URL, like a user's ID, you can define parameters in your route using curly braces <code>{}</code>. These parameters are then passed to your component in a special <code>$path</code> array.</p> <pre><code>&lt;?php\nuse PhpSPA\\Component;\n\n$userProfile = new Component(function (array $path) {\n   // The 'id' from the URL is available in the $path array\n   $userId = $path['id'] ?? 'guest';\n\n   return &lt;&lt;&lt;HTML\n      &lt;h1&gt;User Profile&lt;/h1&gt;\n      &lt;p&gt;You are viewing the profile for User ID: &lt;strong&gt;{$userId}&lt;/strong&gt;&lt;/p&gt;\n   HTML;\n});\n\n// This route will match URLs like /user/123, /user/456, etc.\n$userProfile-&gt;route('/user/{id}');\n</code></pre>"},{"location":"routing/advanced-routing/#typed-parameters-and-constraints","title":"Typed Parameters and Constraints","text":"<p>Type Validation</p> <p>You can enforce specific data types and constraints directly in your route definition. This is great for validation and ensuring your component receives the correct type of data.</p> Integer TypeAlphanumericArray TypeRange ConstraintUnion TypesNested Types <pre><code>&lt;?php\n\n// Only match if 'id' is an integer\n$component-&gt;route('/post/{id: int}');\n</code></pre> <pre><code>&lt;?php\n\n// Match if 'username' is alphanumeric\n$component-&gt;route('/profile/{username: alnum}');\n</code></pre> <pre><code>&lt;?php\n\n// Match if 'tags' is an array of strings\n$component-&gt;route('/posts/{tags: array&lt;string&gt;}');\n</code></pre> <pre><code>&lt;?php\n\n// Match an integer between 2 and 5 (inclusive)\n$component-&gt;route('/rating/{value: int&lt;2,5&gt;}');\n</code></pre> <pre><code>&lt;?php\n\n// Match if 'username' is a string or an integer\n$component-&gt;route('/user/{username: string|int}');\n</code></pre> <pre><code>&lt;?php\n\n// Even complex nested types are supported\n$component-&gt;route('/user/{username: array&lt;array&lt;string&gt;&gt;}/post/{id: array&lt;int&lt;999,999&gt;, string&gt;}');\n</code></pre>"},{"location":"routing/advanced-routing/#multiple-routes-and-http-methods","title":"Multiple Routes and HTTP Methods","text":"<p>Flexible Routing</p> <p>You can assign multiple routes or HTTP methods to a single component.</p> <ul> <li> <p> Multiple Routes</p> <p>Pass an array of paths to the <code>-&gt;route()</code> method.</p> </li> <li> <p> HTTP Methods</p> <p>Pass a pipe-separated string to the <code>-&gt;method()</code> method.</p> </li> </ul> <pre><code>&lt;?php\n\n$dashboard = new Component(function () {\n   return '&lt;h1&gt;Welcome to your Dashboard!&lt;/h1&gt;';\n});\n\n// This component will render for both /home and /dashboard\n$dashboard-&gt;route(['/home', '/dashboard']);\n\n$contactForm = new Component(function (Request $request) {\n   if ($request-&gt;isMethod('POST')) {\n      // Handle form submission...\n      return '&lt;p&gt;Thank you for your message!&lt;/p&gt;';\n   }\n   // Show the form on GET request\n   return '&lt;form method=\"POST\"&gt;&lt;/form&gt;';\n});\n\n// This component responds to both GET and POST requests on the same URL\n$contactForm-&gt;route('/contact')-&gt;method('GET|POST');\n</code></pre>"},{"location":"routing/component-configuration/","title":"Component Configuration","text":"<p>PhpSPA provides several powerful methods to configure how your components behave. These methods can be chained directly onto your component instances to customize routing, rendering, titles, and more.</p> <p>Method Chaining</p> <p>All component configuration methods return the component instance, allowing you to chain multiple configurations together.</p>"},{"location":"routing/component-configuration/#setting-the-page-title","title":"Setting the Page Title","text":"<p>Use the <code>-&gt;title()</code> method to set a dynamic page title for a component. This updates the browser's title bar when the component is loaded.</p> <pre><code>&lt;?php\nuse PhpSPA\\Component;\n\n$homePage = new Component(function() {\n    return '&lt;h1&gt;Welcome Home!&lt;/h1&gt;';\n});\n\n$homePage\n    -&gt;route('/')\n    -&gt;title('Home - My App');\n</code></pre> <p>Dynamic Titles</p> <p>Each component can have its own unique title, making your SPA feel like a traditional multi-page application.</p>"},{"location":"routing/component-configuration/#specifying-http-methods","title":"Specifying HTTP Methods","text":"<p>By default, components accept both <code>GET</code> and <code>POST</code> requests. Use the <code>-&gt;method()</code> method to restrict which HTTP methods are allowed.</p> <pre><code>&lt;?php\nuse PhpSPA\\Component;\n\n// Only accept GET requests\n$viewPage = new Component(fn() =&gt; '&lt;div&gt;Read-only content&lt;/div&gt;');\n$viewPage\n    -&gt;route('/view')\n    -&gt;method('GET');\n\n// Only accept POST requests (for form submissions)\n$submitForm = new Component(function() {\n    return '&lt;div&gt;Form submitted!&lt;/div&gt;';\n});\n$submitForm\n    -&gt;route('/submit')\n    -&gt;method('POST');\n\n// Accept multiple methods\n$apiEndpoint = new Component(fn() =&gt; '&lt;div&gt;API Response&lt;/div&gt;');\n$apiEndpoint\n    -&gt;route('/api/data')\n    -&gt;method('GET|POST|PUT|DELETE');\n</code></pre> <p>Use Cases</p> <ul> <li>GET only: Read-only pages, documentation</li> <li>POST only: Form submissions, data creation</li> <li>Multiple methods: API endpoints, flexible handlers</li> </ul>"},{"location":"routing/component-configuration/#setting-the-target-render-element","title":"Setting the Target Render Element","text":"<p>Components can render into specific elements in your layout using the <code>-&gt;targetID()</code> method. This is useful for rendering different components in different areas of your page.</p> <pre><code>&lt;?php\nuse PhpSPA\\Component;\n\n// Render in the main content area\n$mainContent = new Component(fn() =&gt; '&lt;div&gt;Main Content&lt;/div&gt;');\n$mainContent\n    -&gt;route('/dashboard')\n    -&gt;targetID('main-content');\n\n// Render in a sidebar\n$sidebar = new Component(fn() =&gt; '&lt;div&gt;Sidebar Widget&lt;/div&gt;');\n$sidebar\n    -&gt;route('/sidebar')\n    -&gt;targetID('sidebar');\n</code></pre> <p>In your layout:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n    &lt;div id=\"main-content\"&gt;&lt;/div&gt;\n    &lt;aside id=\"sidebar\"&gt;&lt;/aside&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Default Target ID</p> <p>Set a default target ID for all components using <code>$app-&gt;defaultTargetID(\"app\")</code>. Individual components can override this with their own <code>-&gt;targetID()</code>.</p>"},{"location":"routing/component-configuration/#route-case-sensitivity","title":"Route Case Sensitivity","text":"<p>By default, routes are case-insensitive. You can control this behavior per component or globally.</p>"},{"location":"routing/component-configuration/#per-component-case-sensitivity","title":"Per-Component Case Sensitivity","text":"Case SensitiveCase Insensitive <p>Make a specific route case-sensitive:</p> <pre><code>&lt;?php\n$component = new Component(fn() =&gt; '&lt;div&gt;Content&lt;/div&gt;');\n$component\n    -&gt;route('/AboutUs')\n    -&gt;caseSensitive();\n\n// Only matches: /AboutUs\n// Does NOT match: /aboutus, /ABOUTUS\n</code></pre> <p>Explicitly make a route case-insensitive:</p> <pre><code>&lt;?php\n$component = new Component(fn() =&gt; '&lt;div&gt;Content&lt;/div&gt;');\n$component\n    -&gt;route('/contact')\n    -&gt;caseInsensitive();\n\n// Matches: /contact, /Contact, /CONTACT, /CoNtAcT\n</code></pre> <p>When to Use Case Sensitivity</p> <ul> <li>Case sensitive: API endpoints, specific resource identifiers</li> <li>Case insensitive (default): User-facing pages for better accessibility</li> </ul>"},{"location":"routing/component-configuration/#global-case-sensitivity","title":"Global Case Sensitivity","text":"<p>Make all routes case-sensitive by default:</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\n\n$app = new App($layout);\n\n// Make all routes case-sensitive by default\n$app-&gt;defaultToCaseSensitive();\n\n// Individual components can still override this\n$flexibleComponent = new Component(fn() =&gt; '&lt;div&gt;Flexible&lt;/div&gt;');\n$flexibleComponent\n    -&gt;route('/flexible')\n    -&gt;caseInsensitive(); // This one is still case-insensitive\n</code></pre> <p>Best Practice</p> <p>For consistency, set a global default and only override it for specific components that need different behavior.</p>"},{"location":"routing/component-configuration/#complete-configuration-example","title":"Complete Configuration Example","text":"<p>Here's an example using all configuration methods together:</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\nuse PhpSPA\\Component;\n\n$app = new App($layout);\n\n// Set global defaults\n$app-&gt;defaultTargetID('app');\n$app-&gt;defaultToCaseSensitive();\n\n// Configure a fully customized component\n$userProfile = new Component(function() {\n    return &lt;&lt;&lt;HTML\n        &lt;div class=\"profile\"&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;p&gt;Welcome to your profile page!&lt;/p&gt;\n        &lt;/div&gt;\n    HTML;\n});\n\n$userProfile\n    -&gt;route('/user/profile')\n    -&gt;title('My Profile - UserApp')\n    -&gt;method('GET|POST')\n    -&gt;targetID('main-content')\n    -&gt;caseInsensitive();\n\n$app-&gt;attach($userProfile);\n$app-&gt;run();\n</code></pre> <ul> <li> <p> title(string $title)</p> <p>Sets the page title shown in the browser tab</p> <p>Example: <code>-&gt;title('Dashboard')</code></p> </li> <li> <p> method(string $method)</p> <p>Specifies allowed HTTP methods</p> <p>Default: <code>'GET|POST'</code></p> </li> <li> <p> targetID(string $id)</p> <p>Sets which element the component renders into</p> <p>Example: <code>-&gt;targetID('app')</code></p> </li> <li> <p> caseSensitive()</p> <p>Makes the route case-sensitive</p> <p>Only exact case matches work</p> </li> <li> <p> caseInsensitive()</p> <p>Makes the route case-insensitive</p> <p>Default behavior for routes</p> </li> </ul>"},{"location":"security/content-security-policy/","title":"Security: Content Security Policy (CSP)","text":"<p>To protect your application from Cross-Site Scripting (XSS) attacks, PhpSPA includes a simple helper for implementing a nonce-based Content Security Policy. This ensures that only the inline scripts and styles you've authorized can be executed by the browser.</p> <p>XSS Protection</p> <p>CSP helps prevent malicious scripts from executing in your application.</p>"},{"location":"security/content-security-policy/#step-1-enable-csp","title":"Step 1: Enable CSP","text":"<p>In your application's entry point (e.g., <code>index.php</code>), call <code>Nonce::enable()</code> before any output is sent. This will automatically generate a unique, secure nonce for each request and send the appropriate CSP header.</p> <pre><code>&lt;?php\nuse PhpSPA\\Http\\Security\\Nonce;\nuse PhpSPA\\App;\n\n// Enable a strict CSP policy before creating your app\nNonce::enable();\n\n// You can also customize the allowed sources\nNonce::enable([\n   'script-src' =&gt; [\"https://cdn.jsdelivr.net\"], // By default, 'self' is allowed\n   'style-src'  =&gt; [\"https://fonts.googleapis.com\"], // By default, 'self' is allowed\n]);\n\n// Now, create your app as usual\n$app = new App($layout);\n// ...\n</code></pre> <p>Custom Sources</p> <p>You can also customize the allowed sources for scripts and styles.</p>"},{"location":"security/content-security-policy/#step-2-apply-the-nonce-to-your-tags","title":"Step 2: Apply the Nonce to Your Tags","text":"<p>Now, you must add the generated nonce attribute to every inline <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> tag in your application. The <code>Nonce::attr()</code> method generates the full HTML attribute string for you (e.g., <code>nonce=\"a1b2c3d4\"</code>).</p> <p>This is typically done in your main Layout file.</p> <pre><code>&lt;?php\nuse PhpSPA\\Http\\Security\\Nonce;\n\nfunction Layout() {\n   // Get the nonce attribute string\n   $nonce = Nonce::attr();\n\n   return &lt;&lt;&lt;HTML\n      &lt;!DOCTYPE html&gt;\n      &lt;html&gt;\n      &lt;head&gt;\n         &lt;title&gt;My Secure App&lt;/title&gt;\n\n         &lt;!-- Apply the nonce to the style tag --&gt;\n         &lt;style {$nonce}&gt;\n            body { font-family: sans-serif; }\n         &lt;/style&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n         &lt;div id=\"app\"&gt;&lt;/div&gt;\n\n         &lt;!-- Apply the nonce to the script tag --&gt;\n         &lt;script {$nonce}&gt;\n            console.log('This script is allowed to run!');\n         &lt;/script&gt;\n      &lt;/body&gt;\n      &lt;/html&gt;\n   HTML;\n}\n</code></pre> <p>Security Hardened</p> <p>By following these two steps, you significantly harden your application's security against injection attacks. \ud83d\udc4d</p> <ul> <li>Use <code>Nonce::nonce()</code> to get just the nonce value if you need it for other purposes</li> <li>Call <code>Nonce::disable()</code> to turn off CSP maybe for another new Application instance</li> </ul>"},{"location":"security/cors/","title":"Configuration: Handling CORS \ud83c\udf0d","text":"<p>If you intend for your PhpSPA application to be used as an API for a frontend hosted on a different domain, you'll need to configure Cross-Origin Resource Sharing (CORS).</p> <p>Simple CORS Configuration</p> <p>PhpSPA makes this incredibly simple with the <code>-&gt;cors()</code> method, which you can chain directly onto your <code>$app</code> instance.</p>"},{"location":"security/cors/#enabling-with-defaults","title":"Enabling with Defaults","text":"<p>To enable CORS with a secure and sensible set of default headers, simply call the <code>cors()</code> method with no arguments. This is often all you need.</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\n\n$app = new App($layout);\n\n// Enable CORS with default settings\n$app-&gt;cors();\n\n// ... attach components, etc.\n\n$app-&gt;run();\n</code></pre> <p>Quick Setup</p> <p>The default configuration is suitable for most use cases and includes secure CORS headers.</p>"},{"location":"security/cors/#customizing-cors-settings","title":"Customizing CORS Settings","text":"<p>For more specific control, you can pass an associative array to the <code>cors()</code> method to define exactly which origins, methods, and headers are allowed.</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\n\n$app = new App($layout);\n\n// Enable CORS with custom settings\n$app-&gt;cors([\n    'allow_origins' =&gt; ['https://my-frontend-app.com', 'https://staging.my-app.com'],\n    'allow_methods' =&gt; ['GET', 'POST', 'PUT', 'DELETE'],\n    'allow_headers' =&gt; ['Authorization', 'Content-Type', 'X-Requested-With'],\n    'allow_credentials' =&gt; true,\n    'max_age' =&gt; 86400, // Cache preflight requests for 24 hours\n]);\n\n// ...\n\n$app-&gt;run();\n</code></pre> <p>Fine-Grained Control</p> <p>This gives you fine-grained control to securely manage how your PhpSPA backend interacts with other web applications.</p>"},{"location":"security/cors/#configuration-options","title":"Configuration Options","text":"<ul> <li> <p> allow_origins</p> <p>Array of allowed domain origins</p> <p>Example: <code>['https://example.com']</code></p> </li> <li> <p> allow_methods</p> <p>HTTP methods to allow</p> <p>Example: <code>['GET', 'POST', 'PUT']</code></p> </li> <li> <p> allow_headers</p> <p>Headers that can be used in requests</p> <p>Example: <code>['Authorization', 'Content-Type']</code></p> </li> <li> <p> allow_credentials</p> <p>Allow cookies and authentication</p> <p>Default: <code>false</code></p> </li> <li> <p> max_age</p> <p>Preflight cache duration in seconds</p> <p>Default: <code>3600</code> (1 hour)</p> </li> </ul>"},{"location":"security/csrf-protection/","title":"CSRF Protection","text":"<p>Cross-Site Request Forgery (CSRF) is a common web security vulnerability. PhpSPA provides a simple and powerful way to protect your forms from these attacks, ensuring that submitted data comes from your actual site and not a malicious one.</p> <p>Security Layer</p> <p>CSRF protection validates that form submissions originate from your site, not from external malicious sources.</p>"},{"location":"security/csrf-protection/#protecting-forms-with-the-csrf-component","title":"Protecting Forms with the <code>Csrf</code> Component","text":"<p>The easiest way to add CSRF protection is by using the built-in <code>&lt;Component.Csrf /&gt;</code> component inside your forms.</p> <p>You must give it a unique <code>name</code> prop for each form to prevent token conflicts.</p> <pre><code>&lt;?php\nfunction ContactForm() {\n   return &lt;&lt;&lt;HTML\n      &lt;form method=\"POST\" action=\"/contact\"&gt;\n\n         &lt;Component.Csrf name=\"contact-form\" /&gt;\n\n         &lt;input type=\"text\" name=\"name\" required&gt;\n         &lt;textarea name=\"message\" required&gt;&lt;/textarea&gt;\n         &lt;button type=\"submit\"&gt;Send Message&lt;/button&gt;\n      &lt;/form&gt;\n   HTML;\n}\n</code></pre> <p>Unique Names</p> <p>You must give it a unique <code>name</code> prop for each form to prevent token conflicts.</p>"},{"location":"security/csrf-protection/#verifying-the-token","title":"Verifying the Token","text":"<p>On the server-side, you instantiate the <code>Csrf</code> class with the same form name and call the <code>verify()</code> method.</p> <pre><code>&lt;?php\nuse PhpSPA\\Http\\Request;\nuse Component\\Csrf;\n\nfunction handleContactSubmission(Request $request) {\n   if ($request-&gt;isMethod('POST')) {\n\n      // 1. Create a Csrf instance with the matching name.\n      $csrf = new Csrf(\"contact-form\");\n\n      // 2. Verify the submitted token.\n      if (!$csrf-&gt;verify()) {\n         // Stop execution if the token is invalid or missing.\n         http_response_code(403);\n         die('Invalid CSRF token!');\n      }\n\n      // --- Token is valid, process the form data safely ---\n      $name = $request('name');\n      // ...\n   }\n}\n</code></pre> <p>Token Reusability</p> <p>By default, <code>verify()</code> consumes the token, so it can only be used once. To verify a token without expiring it, pass <code>false</code>:</p> <pre><code>&lt;?php\n\nif ($csrf-&gt;verify(false)) {\n   // Token is valid and reusable.\n}\n</code></pre>"}]}
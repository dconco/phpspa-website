{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"PhpSPA        \ud83d\udc4b <p>     Ready to build modern, reactive web UIs without leaving the comfort of PHP? You're in the right place. </p> <p>What is PhpSPA?</p> <p>PhpSPA is a component-based library that brings the power and syntax of React to your PHP workflow. You build small, reusable components, and the library handles the magic of rendering them and updating the UI when their state changes.</p> <p> </p>"},{"location":"#quick-start","title":"Quick Start","text":"<ul> <li> <p> Installation</p> <p>Get started with PhpSPA in seconds using Composer</p> <p> Install Now</p> </li> <li> <p> Core Concepts</p> <p>Learn the fundamentals of App and Component</p> <p> Learn Basics</p> </li> <li> <p> Routing</p> <p>Master dynamic routing and navigation</p> <p> Explore Routing</p> </li> <li> <p> State Management</p> <p>Build reactive UIs with useState and useEffect</p> <p> Manage State</p> </li> </ul>"},{"location":"#key-features","title":"Key Features","text":"Component-BasedReactive StateClient-Side RoutingPHP Functions from JS <p>Build your UI with small, reusable components just like React</p> <pre><code>&lt;?php\n\nfunction Button() {\n   return &lt;&lt;&lt;HTML\n     &lt;button&gt;Click Me&lt;/button&gt;\n   HTML;\n}\n</code></pre> <p>Components automatically re-render when state changes</p> <pre><code>&lt;?php\n\n$count = useState('count', 0);\n\nreturn \"&lt;button onclick='setState(\\\"count\\\", {$count} + 1)'&gt;\n   Count: {$count}\n&lt;/button&gt;\";\n</code></pre> <p>Navigate between pages without full page reloads</p> <pre><code>&lt;Component.Link to=\"/about\"&gt;About&lt;/Component.Link&gt;\n</code></pre> <p>Call PHP functions directly from JavaScript without APIs</p> <pre><code>&lt;?php\n\n$greeter = useFunction(fn($name) =&gt; \"Hello, $name!\");\n\nconst greeting = await {$greeter('name')};\n</code></pre> <p>Documentation Overview</p> <p>This documentation is designed to be fast and straight to the point. No long stories, just code. Let's dive in and start building something awesome. \ud83d\ude80</p>"},{"location":"core-concepts/","title":"Core Concepts: App &amp; Component","text":"<p> Everything in PhpSPA revolves around two main classes: <code>App</code> and <code>Component</code>. </p> <ul> <li> <p> App</p> <p>This is the main container for your entire application. It holds your layout and manages all your components.</p> </li> <li> <p> Component</p> <p>This is a reusable piece of your UI. Think of it as a simple PHP function that outputs HTML.</p> </li> </ul> <p>Simple Workflow</p> <p>You create one <code>App</code> instance, create your <code>Component</code>s, and then attach them to the app.</p>"},{"location":"core-concepts/#heres-how-they-work-together","title":"Here's how they work together:","text":"<pre><code>&lt;?php\n\nuse PhpSPA\\App;\nuse PhpSPA\\Component;\n\n// 1. Define a layout. It must have a `body()` function.\n$Layout = function () {\n   return body(); // This is where your component's content will be rendered.\n};\n\n// 2. Create the main application instance with your layout.\n$app = new App($Layout);\n\n// 3. Create a component. It's just a function that returns HTML.\n$homePage = new Component(function () {\n   return \"&lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;\";\n});\n\n// 4. Configure the component (e.g., set its route).\n$homePage-&gt;route('/');\n\n// 5. Attach the component to the app.\n$app-&gt;attach($homePage);\n\n// 6. Run the application to render the page.\n$app-&gt;run();\n</code></pre>"},{"location":"installation/","title":"\ud83d\ude80 Installation","text":"<p> Getting PhpSPA up and running is simple. You have two options: use our pre-configured template for a new project, or install the library into an existing one. </p>"},{"location":"installation/#using-the-template-recommended","title":"Using the Template (Recommended)","text":"<p>Quick Setup</p> <p>This is the quickest way to start a new project. It sets up the entire project structure for you.</p> <p>Step 1: Create the Project</p> <p>Run the following command to clone the template into a new directory.</p> <pre><code>composer create-project phpspa/phpspa my-app\n</code></pre> <p>Step 2: Navigate to Your Project</p> <pre><code>cd my-app\n</code></pre> <p>Step 3: Start the Development Server</p> <p>The template comes with a built-in PHP development server.</p> <pre><code>composer start\n</code></pre> <p>That's it!</p> <p>Your PhpSPA application is now running and ready for you to start building. \u2728</p>"},{"location":"installation/#starting-from-scratch","title":"Starting From Scratch","text":"<p>Existing Projects</p> <p>If you want to integrate PhpSPA into an existing project, you can install it directly with Composer.</p> <pre><code>composer require dconco/phpspa\n</code></pre> <p>Additional Setup Required</p> <p>You will then need to set up your own layout and <code>index.php</code> file to initialize the <code>App</code> class.</p>"},{"location":"layout/","title":"The Layout","text":"<p> Your Layout is the main HTML shell that wraps your entire application. It's where you define your <code>&lt;html&gt;</code> document, the <code>&lt;head&gt;</code> section, and any global scripts or styles. </p> <p>Simple Rule</p> <p>A layout has a simple rule:</p> <p>Provide a target element. This is where your components will be rendered. A common &amp; default choice is <code>&lt;div id=\"app\"&gt;&lt;/div&gt;</code>.</p>"},{"location":"layout/#example-layout-layoutphp","title":"Example Layout (<code>/layout.php</code>)","text":"<p>Layout Structure</p> <p>This file simply returns a function that outputs your HTML structure.</p> <pre><code>&lt;?php\n\nreturn fn () =&gt; &lt;&lt;&lt;HTML\n   &lt;!DOCTYPE html&gt;\n   &lt;html&gt;\n      &lt;head&gt;\n         &lt;title&gt;My Awesome App&lt;/title&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n         &lt;div id=\"app\"&gt;&lt;/div&gt;\n      &lt;/body&gt;\n   &lt;/html&gt;\nHTML;\n</code></pre>"},{"location":"layout/#using-the-layout","title":"Using the Layout","text":"<p>You then pass this layout directly to your <code>App</code> when you create it.</p> <pre><code>&lt;?php\n\nuse PhpSPA\\App;\n\n// Load the layout file\n$layout = require __DIR__ . '/layout.php';\n\n// Initialize the app with the layout\n$app = new App($layout);\n</code></pre> <p>Result</p> <p>Now, all components attached to your app will be rendered inside that <code>&lt;div id=\"app\"&gt;&lt;/div&gt;</code>.</p>"},{"location":"layout/#setting-the-default-target-id","title":"Setting the Default Target ID","text":"<p>By default, PhpSPA looks for an element with the ID <code>app</code> to render components. However, you can change this to any ID you prefer using the <code>defaultTargetID()</code> method.</p> <pre><code>&lt;?php\n\nuse PhpSPA\\App;\n\n$layout = require __DIR__ . '/layout.php';\n$app = new App($layout);\n\n// Set the default target ID for all components\n$app-&gt;defaultTargetID('app'); // This is the default\n\n// Or use a custom ID\n$app-&gt;defaultTargetID('main-content');\n</code></pre> <p>Custom Target Element</p> <p>If your layout uses a different ID like <code>&lt;div id=\"main-content\"&gt;&lt;/div&gt;</code>, make sure to set it with <code>defaultTargetID()</code>.</p>"},{"location":"layout/#example-with-custom-target","title":"Example with Custom Target","text":"<pre><code>&lt;?php\n// Layout file with custom ID\nreturn fn () =&gt; &lt;&lt;&lt;HTML\n   &lt;!DOCTYPE html&gt;\n   &lt;html&gt;\n      &lt;head&gt;\n         &lt;title&gt;My App&lt;/title&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n         &lt;header&gt;Site Header&lt;/header&gt;\n         &lt;div id=\"main-content\"&gt;&lt;/div&gt;\n         &lt;footer&gt;Site Footer&lt;/footer&gt;\n      &lt;/body&gt;\n   &lt;/html&gt;\nHTML;\n</code></pre> <pre><code>&lt;?php\n// index.php\nuse PhpSPA\\App;\n\n$layout = require __DIR__ . '/layout.php';\n$app = new App($layout);\n\n// Tell PhpSPA to render components inside #main-content\n$app-&gt;defaultTargetID('main-content');\n\n// ... attach components and run\n$app-&gt;run();\n</code></pre> <p>Flexible Layouts</p> <p>This allows you to create complex layouts with headers, sidebars, and footers, while controlling exactly where your dynamic content renders.</p>"},{"location":"components/","title":"The Power of Components","text":"<p> The core of PhpSPA is its component-based architecture. A component is a reusable piece of your UI, defined as a simple PHP function that returns an HTML string. </p> <p>The Magic</p> <p>The magic happens when you use these components like HTML tags inside the <code>heredoc</code> string of another component. This allows you to build complex pages by nesting smaller, reusable parts.</p>"},{"location":"components/#functional-components","title":"Functional Components","text":"<p>Simple Component</p> <p>First, define a simple component.</p> <pre><code>&lt;?php\n// A simple, reusable button component\nfunction Button() {\n   return &lt;&lt;&lt;HTML\n     &lt;button&gt;Click Me&lt;/button&gt;\n   HTML;\n}\n</code></pre> <p>Now, use that <code>Button</code> component inside a main page component.</p> <pre><code>&lt;?php\nfunction HomePage() {\n   return &lt;&lt;&lt;HTML\n      &lt;div class=\"container\"&gt;\n         &lt;h1&gt;Welcome!&lt;/h1&gt;\n         &lt;p&gt;Click the button below to continue.&lt;/p&gt;\n\n         &lt;Button /&gt;\n      &lt;/div&gt;\n   HTML;\n}\n</code></pre>"},{"location":"components/#handling-children-and-props","title":"Handling Children and Props","text":"<p>True Power</p> <p>Components become truly powerful when you pass data to them as props (attributes) and children (content inside the tags).</p> Example Components with PropsComposing Them in a Page <pre><code>&lt;?php\nuse function Component\\HTMLAttrInArrayToString;\n\n// Accepts children\nfunction Card($children) {\n   return &lt;&lt;&lt;HTML\n      &lt;div class=\"card\"&gt;\n         {$children}\n      &lt;/div&gt;\n   HTML;\n}\n\n// Accepts props and children\nfunction LinkButton($to, $children, ...$attributes) {\n   // Convert any extra HTML attributes into a string\n   $attrString = HTMLAttrInArrayToString($attributes);\n\n   return &lt;&lt;&lt;HTML\n     &lt;a href=\"{$to}\" {$attrString}&gt;\n       {$children}\n     &lt;/a&gt;\n   HTML;\n}\n</code></pre> <p>Now, let's use these components inside a <code>UserProfile</code> component. This shows how everything nests together.</p> <pre><code>&lt;?php\nfunction UserProfile() {\n   return &lt;&lt;&lt;HTML\n      &lt;Card&gt;\n         &lt;h2&gt;User Dashboard&lt;/h2&gt;\n         &lt;p&gt;Welcome back! Here are your options:&lt;/p&gt;\n\n         &lt;LinkButton to=\"/settings\" class=\"btn btn-primary\"&gt;\n            Edit Settings\n         &lt;/LinkButton&gt;\n\n         &lt;LinkButton to=\"/logout\" class=\"btn btn-secondary\"&gt;\n            Log Out\n         &lt;/LinkButton&gt;\n      &lt;/Card&gt;\n   HTML;\n}\n</code></pre> <p>Key Takeaway</p> <p>You build your entire UI by composing these components. As long as the final output is one component attached to the <code>App</code> class, <code>PhpSPA</code> will handle rendering the entire nested tree.</p>"},{"location":"components/advanced-component/","title":"Advanced Component Patterns","text":"<p> Beyond simple functions, PhpSPA offers several powerful ways to structure and call your components, giving you flexibility for any project architecture. </p>"},{"location":"components/advanced-component/#class-based-components","title":"Class-Based Components","text":"<p>Complex Components</p> <p>For more complex components that might have their own methods or properties, you can use a class. If a class has a <code>__render()</code> method, <code>PhpSPA</code> will automatically call it when the class is used as a component. Props and children are passed as arguments to the <code>__render</code> method.</p> <pre><code>&lt;?php\nclass Alert {\n   // This method is called automatically\n   public function __render($type, $children) {\n      $class = \"alert alert-{$type}\"; // e.g., 'alert alert-success'\n\n      return &lt;&lt;&lt;HTML\n         &lt;div class=\"{$class}\"&gt;\n            {$children}\n         &lt;/div&gt;\n      HTML;\n   }\n}\n\n// How to use it:\nfunction StatusMessage() {\n   return &lt;&lt;&lt;HTML\n      &lt;Alert type=\"success\"&gt;\n         &lt;strong&gt;Success!&lt;/strong&gt; Your profile has been updated.\n      &lt;/Alert&gt;\n   HTML;\n}\n</code></pre> <p>Method Components</p> <p>You can even call other public methods of a class directly as components using the <code>::</code> syntax.</p> <pre><code>&lt;MyComponent::Header /&gt;\n&lt;MyComponent::Footer /&gt;\n</code></pre>"},{"location":"components/advanced-component/#namespaced-and-variable-components","title":"Namespaced and Variable Components","text":"<p>Flexible Organization</p> <p>PhpSPA makes it easy to organize and use components from different parts of your codebase.</p> Namespaced ComponentsCallable Variable Components <p>If your component function is in a namespace, use a dot (<code>.</code>) instead of a backslash (<code>\\</code>) to call it.</p> <pre><code>&lt;?php\n// Assuming Button is in the UI\\Elements namespace\nfunction SomePage() {\n   return &lt;&lt;&lt;HTML\n      &lt;UI.Elements.Button /&gt;\n   HTML;\n}\n</code></pre> <p>You can assign a component to a variable and use it directly. This is great for dynamic components or for keeping your template logic clean. To use a variable component, prefix its name with <code>@</code> or <code>$</code> (if using <code>$</code>, escape it within <code>heredoc</code> strings: <code>&lt;\\$Link /&gt;</code>).</p> <pre><code>&lt;?php\nfunction Navigation() {\n   // Define a component as a callable variable\n   $NavLink = fn ($to, $children) =&gt; &lt;&lt;&lt;HTML\n      &lt;a href=\"{$to}\" class=\"nav-link\"&gt;{$children}&lt;/a&gt;\n   HTML;\n\n   // Export the variable to make it available in the heredoc scope\n   scope(compact('NavLink'));\n\n   // Use the variable component with the @ prefix\n   return &lt;&lt;&lt;HTML\n      &lt;nav&gt;\n         &lt;@NavLink to=\"/\"&gt;Home&lt;/@NavLink&gt;\n         &lt;@NavLink to=\"/about\"&gt;About&lt;/@NavLink&gt;\n\n         &lt;!-- Or using the $ prefix (escaped) --&gt;\n         &lt;\\$NavLink to=\"/contact\"&gt;Contact&lt;/\\$NavLink&gt;\n      &lt;/nav&gt;\n   HTML;\n}\n</code></pre>"},{"location":"hooks/updating-state-of-mapped-arrays/","title":"Updating State of Mapped Arrays","text":"<p>State becomes truly useful when you modify it based on user actions, like clicking a button. This is done using the client-side <code>setState()</code> function.</p> <p>Two Approaches</p> <p>You can update state in two primary ways: a quick inline method for simple changes, and a more robust script-based method for complex logic.</p>"},{"location":"hooks/updating-state-of-mapped-arrays/#the-direct-way-inline-updates","title":"The Direct Way: Inline Updates","text":"<p>For simple actions like adding a new item to a list, you can call <code>setState()</code> directly within an HTML attribute like <code>onclick</code>.</p> <p>This approach uses the JavaScript spread syntax (<code>...</code>) to create a new array that includes all the old items plus the new one.</p> <pre><code>&lt;?php\nuse function Component\\useState;\n\nfunction TodoList() {\n   $todos = useState('todos', [\n      ['id' =&gt; 1, 'text' =&gt; 'Learn phpspa'],\n   ]);\n\n   $newId = count($todos()) + 1;\n\n   return &lt;&lt;&lt;HTML\n      &lt;div&gt;\n         &lt;h3&gt;My To-Do List&lt;/h3&gt;\n         &lt;ul&gt;\n            {$todos-&gt;map(fn($item) =&gt; \"&lt;li&gt;{$item['text']}&lt;/li&gt;\")}\n         &lt;/ul&gt;\n\n         &lt;button onclick='setState(\"todos\", [...{$todos}, { id: {$newId}, text: \"A new task\" }])'&gt;\n            Add Todo\n         &lt;/button&gt;\n      &lt;/div&gt;\n   HTML;\n}\n</code></pre> <p>Spread Syntax</p> <p>This approach uses the JavaScript spread syntax (<code>...</code>) to create a new array that includes all the old items plus the new one.</p>"},{"location":"hooks/updating-state-of-mapped-arrays/#the-customizable-way-using-a-script","title":"The Customizable Way: Using a Script","text":"<p>When your update logic is more complex (e.g., reading from input fields), it's cleaner to use a dedicated JavaScript function.</p> <p>First, pass your initial state to a JavaScript variable. Then, you can manipulate this variable with standard JavaScript before calling <code>setState()</code> with the final data.</p> <pre><code>&lt;?php\nuse function Component\\useState;\n\nfunction TodoList() {\n   $todos = useState('todos', [\n      ['id' =&gt; 1, 'text' =&gt; 'Learn phpspa'],\n   ]);\n\n   return &lt;&lt;&lt;HTML\n      &lt;div&gt;\n         &lt;h3&gt;My To-Do List&lt;/h3&gt;\n         &lt;ul id=\"todo-list-ul\"&gt;\n            {$todos-&gt;map(fn($item) =&gt; \"&lt;li&gt;{$item['text']}&lt;/li&gt;\")}\n         &lt;/ul&gt;\n\n         &lt;button onclick=\"addTodo()\"&gt;Add Todo&lt;/button&gt;\n      &lt;/div&gt;\n\n      &lt;script&gt;\n         // Get the initial state from PHP\n         let todosData = {$todos};\n\n         function addTodo() {\n            // Perform any logic you need in JavaScript\n            let newId = todosData.length + 1;\n            todosData.push({ id: newId, text: 'New task ' + newId });\n\n            // Update the state with the modified array\n            setState('todos', todosData);\n         }\n      &lt;/script&gt;\n   HTML;\n}\n</code></pre> <p>Complex Logic</p> <p>First, pass your initial state to a JavaScript variable. Then, you can manipulate this variable with standard JavaScript before calling <code>setState()</code> with the final data.</p>"},{"location":"hooks/use-effect/","title":"Handling Side Effects with <code>useEffect</code>","text":"<p>Sometimes you need to perform actions after your component has rendered, like fetching data from an API, logging to the console, or manually manipulating the DOM. These actions are called \"side effects,\" and the <code>useEffect</code> hook is the perfect tool for managing them.</p> <p>Effect Hook</p> <p>The hook takes two arguments: a callback function to run and an array of dependencies to watch.</p>"},{"location":"hooks/use-effect/#basic-usage-watching-for-changes","title":"Basic Usage: Watching for Changes","text":"<p>The most common use case is to run code whenever a specific piece of state changes.</p> <pre><code>&lt;?php\n\nuse function Component\\useState;\nuse function Component\\useEffect;\n\nfunction Counter() {\n   $count = useState('count', 0);\n   $script = '';\n\n   // This effect will run every time the 'count' state changes.\n   useEffect(function ($count) use (&amp;$script) {\n      // This script runs on the client-side after the re-render.\n       $script = \"&lt;script&gt;console.log('The counter is now: {$count}')&lt;/script&gt;\";\n   }, [$count]);\n\n   return &lt;&lt;&lt;HTML\n      &lt;h2&gt;Counter Value: {$count}&lt;/h2&gt;\n      &lt;button onclick=\"setState('count', {$count} + 1)\"&gt;\n         Click to Increment\n      &lt;/button&gt;\n       {$script}\n   HTML;\n}\n</code></pre> <p>Side Effect</p> <p>This effect will run every time the 'count' state changes.</p>"},{"location":"hooks/use-effect/#controlling-the-effect-the-dependency-array","title":"Controlling the Effect: The Dependency Array","text":"<p>The second argument to <code>useEffect</code> is the dependency array. It tells PhpSPA when to run your effect.</p> Specific State ChangesRun Once on Load <p>Provide an array of state variables. The effect will run on the initial render and then again anytime one of those variables changes.</p> <pre><code>&lt;?php\n\nuseEffect($myCallback, [$stateA, $stateB]);\n</code></pre> <p>Provide an empty array <code>[]</code>. The effect will only run once when the component is first loaded. This is perfect for initial setup tasks, like fetching data from an API.</p> <pre><code>&lt;?php\n\nuseEffect(function () use (&amp;$script) {\n   // This runs only once.\n   $script = \"&lt;script&gt;console.log('Component has loaded!')&lt;/script&gt;\";\n}, []);\n</code></pre> <p>Dependency Control</p> <p>Use an empty array <code>[]</code> for effects that should only run once during component initialization.</p>"},{"location":"hooks/use-effect/#updating-state-inside-an-effect","title":"Updating State Inside an Effect","text":"<p>You can also update state from within an effect. This is useful for creating more complex, reactive logic.</p> <p>In this example, when the counter changes, the effect calculates a new value and immediately updates the state again.</p> <pre><code>&lt;?php\n\nfunction EffectExample() {\n   $counter = useState('counter', 0);\n   $message = useState('message', 'Waiting for an update...');\n\n   useEffect(function ($counter) use ($message) {\n      // Calculate a new value based on the current state\n      $newCounterValue = $counter() + 1;\n      $newMessage = \"Counter was {$counter}, but the effect changed it to {$newCounterValue}!\";\n\n      // Update the state from within the effect\n      $counter($newCounterValue);\n      $message($newMessage);\n\n   }, [$counter]); // This effect depends on the counter\n\n   return &lt;&lt;&lt;HTML\n      &lt;div&gt;\n         &lt;p&gt;{$message}&lt;/p&gt;\n         &lt;button onclick=\"setState('counter', {$counter} + 1)\"&gt;Trigger Effect&lt;/button&gt;\n      &lt;/div&gt;\n   HTML;\n}\n</code></pre> <p>Reactive Logic</p> <p>In this example, when the counter changes, the effect calculates a new value and immediately updates the state again.</p>"},{"location":"hooks/use-function/","title":"Calling PHP from JavaScript (<code>useFunction</code>)","text":"<p>Often, you need to run PHP logic\u2014like saving to a database\u2014without a full page reload. The <code>useFunction</code> hook makes this simple without creating separate API routes.</p> <p>Secure Bridge</p> <p>It securely exposes a PHP function so your client-side JavaScript can call it directly.</p>"},{"location":"hooks/use-function/#example-a-simple-greeter-form","title":"Example: A Simple Greeter Form","text":"<p>Let's build a form where a user enters their name, and the server sends back a personalized greeting.</p> <pre><code>&lt;?php\n\nuse PhpSPA\\Component;\nuse function Component\\useFunction;\n\n$greeterPage = new Component(function () {\n    // 1. Define the PHP function you want to call.\n    // It can accept arguments and should return the raw data.\n    $sayHello = function (string $name): string {\n        return \"Hello, \" . htmlspecialchars($name) . \"!\";\n    };\n\n    // 2. Wrap your function with useFunction().\n    $greeter = useFunction($sayHello);\n\n    echo &lt;&lt;&lt;HTML\n        &lt;input type=\"text\" id=\"nameInput\" placeholder=\"Enter your name\"&gt;\n        &lt;button id=\"greetBtn\"&gt;Greet Me&lt;/button&gt;\n\n        &lt;script&gt;\n            const nameInput = document.getElementById('nameInput');\n            const greetBtn = document.getElementById('greetBtn');\n\n            greetBtn.onclick = async () =&gt; {\n                const name = nameInput.value;\n\n                // 3. Call the PHP function from JavaScript!\n                // The argument 'name' here is treated as a JavaScript expression.\n                // It becomes the 'name' variable from the line above.\n                const greeting = await {$greeter('name')};\n\n                // The returned value is the direct output of your PHP function.\n                alert(greeting); // Shows \"Hello, [Name]!\"\n            };\n        &lt;/script&gt;\n    HTML;\n});\n\n$greeterPage-&gt;route('/greeter');\n</code></pre> <p>How It Works</p> <p>When you echo the <code>$greeter('name')</code> object, it generates a JavaScript snippet like <code>phpspa.__call('some-secure-token', name)</code>. The arguments you pass to the caller in PHP are inserted directly as JavaScript expressions.</p> <p>Return Values</p> <p>The <code>phpspa.js</code> library handles the secure AJAX request and returns the exact data from your PHP function (string, array, object, etc.) as a JavaScript promise.</p>"},{"location":"hooks/use-state/","title":"Managing State with <code>useState</code>","text":"<p>State is the data in your component that can change over time. When state changes, PhpSPA automatically re-renders the component to reflect the new data. This is the key to creating dynamic and interactive UIs.</p> <p>The useState Hook</p> <p>The <code>useState</code> hook is how you add state to your components.</p>"},{"location":"hooks/use-state/#a-simple-counter","title":"A Simple Counter","text":"<p>Here's the classic counter example. The <code>useState</code> hook creates a state variable named <code>count</code> with an initial value of <code>0</code>.</p> <pre><code>&lt;?php\nuse function Component\\useState;\n\nfunction Counter() {\n   $count = useState('count', 0);\n\n   // The client-side setState() function updates the state and triggers a re-render.\n   return &lt;&lt;&lt;HTML\n      &lt;div&gt;\n         &lt;h2&gt;Counter Value: {$count}&lt;/h2&gt;\n         &lt;button onclick=\"setState('count', {$count} + 1)\"&gt;\n            Click to Increment\n         &lt;/button&gt;\n      &lt;/div&gt;\n   HTML;\n}\n</code></pre> <p>Understanding State Variables</p> <ul> <li><code>useState('count', 0)</code>: Declares a piece of state named <code>count</code> and sets its default value to <code>0</code></li> <li><code>{$count}</code>: When used in a string, the state variable automatically outputs its current value</li> <li><code>setState('count', ...)</code>: This is a global JavaScript function provided by PhpSPA to update state from the browser</li> </ul>"},{"location":"hooks/use-state/#rendering-lists-with-map","title":"Rendering Lists with <code>map()</code>","text":"<p>If your state holds an array, you can use the powerful <code>-&gt;map()</code> method to iterate over it and render a list of elements.</p> <p>This is perfect for rendering dynamic data, like a list of tasks.</p> <pre><code>&lt;?php\nuse function Component\\useState;\n\nfunction TodoList() {\n   $todos = useState('todos', [\n      ['id' =&gt; 1, 'text' =&gt; 'Learn phpspa'],\n      ['id' =&gt; 2, 'text' =&gt; 'Build an awesome app'],\n      ['id' =&gt; 3, 'text' =&gt; 'Deploy to production']\n   ]);\n\n   return &lt;&lt;&lt;HTML\n      &lt;div&gt;\n         &lt;h3&gt;My To-Do List&lt;/h3&gt;\n         &lt;ul&gt;\n            {$todos-&gt;map(fn($item) =&gt; \"&lt;li&gt;{$item['text']}&lt;/li&gt;\")}\n         &lt;/ul&gt;\n      &lt;/div&gt;\n   HTML;\n}\n</code></pre> <p>Dynamic Rendering</p> <p>The <code>-&gt;map()</code> method loops through each item in the <code>$todos</code> array and runs your function, concatenating the resulting HTML strings into a final list.</p>"},{"location":"navigations/link-component/","title":"Client-Side Navigation: The Link Component","text":"<p>To navigate between pages without a full browser reload, you must use the built-in <code>&lt;Component.Link /&gt;</code>. This component looks like a standard <code>&lt;a&gt;</code> tag, but it's much smarter\u2014it hooks into PhpSPA's router to fetch and render the new component on the fly, providing a seamless, SPA-like user experience. \ud83d\ude80</p> <p>Smart Navigation</p> <p>The <code>&lt;Component.Link /&gt;</code> component prevents full page reloads, giving your app that smooth, instant navigation feel.</p>"},{"location":"navigations/link-component/#basic-usage","title":"Basic Usage","text":"<p>The two main props are <code>to</code> for the destination URL and <code>children</code> for the link's text.</p> <pre><code>&lt;?php\n\nfunction AppHeader() {\n   return &lt;&lt;&lt;HTML\n      &lt;header&gt;\n         &lt;nav&gt;\n            &lt;Component.Link to=\"/\"&gt;Home&lt;/Component.Link&gt;\n            &lt;Component.Link to=\"/about\"&gt;About Us&lt;/Component.Link&gt;\n            &lt;Component.Link to=\"/contact\"&gt;Contact&lt;/Component.Link&gt;\n         &lt;/nav&gt;\n      &lt;/header&gt;\n   HTML;\n}\n</code></pre> <p>Navigation Example</p> <p>The component automatically handles routing and state management for you.</p>"},{"location":"navigations/link-component/#passing-additional-attributes","title":"Passing Additional Attributes","text":"<p>You can pass any standard HTML attribute like <code>class</code> or <code>id</code> directly to the component, and they will be added to the final <code>&lt;a&gt;</code> tag.</p> <pre><code>&lt;?php\n\nfunction AppFooter() {\n   return &lt;&lt;&lt;HTML\n      &lt;footer&gt;\n         &lt;Component.Link to=\"/privacy-policy\" class=\"footer-link\" id=\"privacy-link\"&gt;\n            Privacy Policy\n         &lt;/Component.Link&gt;\n      &lt;/footer&gt;\n   HTML;\n}\n</code></pre> <p>This will render the following HTML:</p> <pre><code>&lt;a href=\"/privacy-policy\" class=\"footer-link\" id=\"privacy-link\"&gt;\n   Privacy Policy\n&lt;/a&gt;\n</code></pre> <p>Best Practice</p> <p>Always use <code>&lt;Component.Link /&gt;</code> for navigating between your app's routes to get that smooth, instant page-load feel.</p>"},{"location":"navigations/navigate-component/","title":"Programmatic Navigation with <code>&lt;Navigate /&gt;</code>","text":"<p>While <code>&lt;Component.Link /&gt;</code> is perfect for user-driven navigation, you'll sometimes need to redirect a user automatically based on some logic (e.g., after a form submission). For this, use the <code>&lt;Component.Navigate /&gt;</code> component.</p> <p>Automatic Redirects</p> <p>When PhpSPA renders this component, it triggers an immediate, client-side redirect without a full page reload.</p>"},{"location":"navigations/navigate-component/#basic-usage","title":"Basic Usage","text":"<p>Simply render the component with a <code>path</code> prop. The redirect will happen as soon as the component is added to the page.</p> <pre><code>&lt;?php\nuse PhpSPA\\Http\\Request;\n\nfunction LoginPage(Request $request) {\n   $isLoggedIn = false;\n   if ($request-&gt;isMethod('POST')) {\n      // ... validate user credentials ...\n      if ($credentialsAreValid) {\n         $isLoggedIn = true;\n      }\n   }\n\n   // Conditionally render the Navigate component or the login form\n   if ($isLoggedIn) {\n      return '&lt;Component.Navigate path=\"/dashboard\" /&gt;';\n   }\n\n   return &lt;&lt;&lt;HTML\n      &lt;form method=\"POST\"&gt;\n         ...\n      &lt;/form&gt;\n   HTML;\n}\n</code></pre> <p>Conditional Redirect</p> <p>Perfect for post-login redirects or access control logic.</p>"},{"location":"navigations/navigate-component/#controlling-browser-history","title":"Controlling Browser History","text":"<p>The <code>&lt;Navigate /&gt;</code> component takes a <code>state</code> prop to control how it interacts with the browser's history.</p> push (Default)replace <p>Adds a new entry to the browser's history. The user can click the \"back\" button to return to the previous page.</p> <pre><code>&lt;Component.Navigate path=\"/dashboard\" state=\"push\" /&gt;\n</code></pre> <p>Replaces the current page in the browser's history. This is ideal for post-login redirects, as it prevents the user from clicking \"back\" to see the login form again.</p> <pre><code>&lt;Component.Navigate path=\"/dashboard\" state=\"replace\" /&gt;\n</code></pre> <p>Post-Login Redirects</p> <p>Use <code>state=\"replace\"</code> to prevent users from navigating back to the login page.</p> <pre><code>&lt;?php\n// Inside your component logic...\n\nif ($isLoggedIn) {\n   // Replace the login page in history so the user can't go back.\n   return '&lt;Component.Navigate path=\"/dashboard\" state=\"replace\" /&gt;';\n}\n</code></pre>"},{"location":"performance/assets-caching/","title":"Assets Caching","text":""},{"location":"performance/assets-caching/#performance-asset-caching","title":"Performance: Asset Caching","text":"<p>To improve performance and reduce server load, you can instruct the user's browser to cache your CSS and JavaScript assets.</p> <p>Cache Control</p> <p>Use the <code>-&gt;assetCacheHours()</code> method on your <code>$app</code> instance to set a cache duration. The library will automatically append a version query string to your asset URLs to handle cache-busting.</p> <pre><code>&lt;?php\n\nuse PhpSPA\\App;\n\n$app = new App($layout);\n\n// Tell the browser to cache all CSS/JS assets for 24 hours.\n$app-&gt;assetCacheHours(24);\n\n// For no caching (useful in development), set it to 0.\n$app-&gt;assetCacheHours(0);\n</code></pre> <p>Development vs Production</p> <ul> <li>Development: Set to <code>0</code> for no caching, so changes are immediately visible</li> <li>Production: Set to <code>24</code> (or higher) for optimal performance and reduced server load</li> </ul>"},{"location":"performance/html-compression/","title":"Performance: HTML Compression","text":"<p>To ensure your application is as fast as possible, PhpSPA includes a powerful, built-in HTML compressor. It automatically minifies your final HTML output by removing whitespace, comments, and other unnecessary characters, which reduces the page size and leads to faster load times. \u26a1</p> <p>Auto-Detection</p> <p>By default, PhpSPA tries to auto-detect the best settings. However, you can take full control for fine-tuned performance.</p>"},{"location":"performance/html-compression/#automatic-compression-default-behavior","title":"Automatic Compression (Default Behavior)","text":"<p>PhpSPA automatically initializes the HTML compressor when you create your <code>App</code> instance. The second parameter controls this behavior and is set to <code>true</code> by default.</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\n\n// Auto-initialization is enabled by default\n$app = new App($layout);\n\n// This is the same as:\n$app = new App($layout, true);\n</code></pre> <p>Smart Detection</p> <p>When auto-initialization is enabled, PhpSPA automatically detects the best compression level based on your server environment. You don't need to manually configure anything!</p>"},{"location":"performance/html-compression/#disabling-auto-initialization","title":"Disabling Auto-Initialization","text":"<p>If you want full manual control over compression, you can disable auto-initialization:</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\n\n// Disable auto-initialization\n$app = new App($layout, false);\n\n// Now you must manually configure compression if you want it\n$app-&gt;compression(Compressor::LEVEL_AGGRESSIVE, true);\n</code></pre> <p>When to Disable</p> <p>Disable auto-initialization only if you need precise control over compression settings for specific use cases.</p>"},{"location":"performance/html-compression/#environment-based-configuration-recommended","title":"Environment-Based Configuration (Recommended)","text":"<p>The easiest way to manage compression is to set the application's environment. PhpSPA will then apply a sensible preset for you.</p> developmentproduction <p>Compression is disabled to make debugging easier.</p> <pre><code>&lt;?php\nuse PhpSPA\\Compression\\Compressor;\n\n$app-&gt;compressionEnvironment(Compressor::ENV_DEVELOPMENT);\n</code></pre> <p>A high level of compression is enabled for maximum performance.</p> <pre><code>&lt;?php\nuse PhpSPA\\Compression\\Compressor;\n\n$app-&gt;compressionEnvironment(Compressor::ENV_PRODUCTION);\n</code></pre> <p>Environment Presets</p> <p>Set the environment to automatically configure compression with sensible defaults.</p>"},{"location":"performance/html-compression/#manual-compression-control","title":"Manual Compression Control","text":"<p>For more granular control, you can manually set the compression level and enable or disable Gzip.</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\nuse PhpSPA\\Compression\\Compressor;\n\n$app = new App($layout);\n\n// Manually set the highest level of compression and enable Gzip\n$app-&gt;compression(Compressor::LEVEL_EXTREME, true);\n</code></pre> <p>Compression Levels</p> <p>There are several levels available, from basic to extreme:</p> <ul> <li><code>Compressor::LEVEL_NONE</code>: No compression is applied</li> <li><code>Compressor::LEVEL_BASIC</code>: Removes comments and basic whitespace</li> <li><code>Compressor::LEVEL_AGGRESSIVE</code>: Performs more intense whitespace removal</li> <li><code>Compressor::LEVEL_EXTREME</code>: Applies the most aggressive minification for the smallest possible file size</li> </ul>"},{"location":"performance/managing-styles-and-scripts/","title":"Managing Styles &amp; Scripts \ud83c\udfa8","text":"<p>PhpSPA offers a powerful way to manage your CSS and JavaScript. You can write them directly in PHP, and the library will automatically serve them as optimized, cache-busting external files for maximum performance.</p> <p>Asset Management</p> <p>PhpSPA automatically generates versioned, cacheable asset files for optimal performance.</p>"},{"location":"performance/managing-styles-and-scripts/#global-assets","title":"Global Assets","text":"<p>For styles and scripts that apply to your entire site, attach them directly to your <code>$app</code> instance.</p> <p>The methods <code>styleSheet()</code> and <code>script()</code> accept a callable that returns your raw code. For better organization, it's recommended to keep this code in separate files.</p> <p>Example (<code>styles/GlobalStyle.php</code>):</p> <pre><code>&lt;?php\n// returns a callable with your CSS code\nreturn fn () =&gt; &lt;&lt;&lt;CSS\n   body {\n      background-color: #f8f9fa;\n      font-family: sans-serif;\n   }\nCSS;\n</code></pre> <p>Example (<code>index.php</code>):</p> <pre><code>&lt;?php\n$app = new App($layout);\n\n// Attach the global style and script from their files\n$app-&gt;styleSheet(require 'styles/GlobalStyle.php', 'global-styles');\n$app-&gt;script(require 'scripts/GlobalScript.php', 'global-scripts');\n</code></pre> <p>Cache-Busting</p> <p>Behind the scenes, PhpSPA creates unique, versioned links like <code>/phpspa/assets/global-styles-a1b2c3d4.css</code>, which allows the browser to cache them effectively. The optional second parameter (<code>'global-styles'</code>) is a name added to the file for easier debugging.</p>"},{"location":"performance/managing-styles-and-scripts/#component-specific-assets","title":"Component-Specific Assets","text":"<p>You also have two ways to add assets that only belong to a specific component.</p> Method Chaining (Cached)Inline Tags (Uncached) <p>This works just like global assets. The code is served in its own cached file.</p> <pre><code>&lt;?php\n$profileComponent = new Component(fn() =&gt; '&lt;div&gt;...&lt;/div&gt;');\n\n$profileComponent\n   -&gt;route('/profile')\n   -&gt;styleSheet(fn() =&gt; '.profile-card { border: 1px solid #ccc; }');\n</code></pre> <p>For very small, component-specific tweaks, you can write standard <code>&lt;style&gt;</code> and <code>&lt;script&gt;</code> tags directly inside your component's <code>heredoc</code> string.</p> <pre><code>&lt;?php\nfunction UserProfile() {\n   return &lt;&lt;&lt;HTML\n      &lt;style&gt;\n         /* This style is not served as a separate cached file */\n         .profile-card {\n            padding: 20px;\n         }\n      &lt;/style&gt;\n\n      &lt;div class=\"profile-card\"&gt;\n         &lt;h2&gt;User Profile&lt;/h2&gt;\n      &lt;/div&gt;\n   HTML;\n}\n</code></pre> <p>Inline Assets</p> <p>Important: This is the simplest method, but these inline assets will not be externally cached by the browser. It's best reserved for small, non-critical snippets.</p>"},{"location":"references/","title":"Reference Index","text":"<p>Welcome to the phpSPA Reference section. Here you'll find detailed documentation for advanced APIs and utilities.</p> <ul> <li>Response API: Learn how to build, send, and customize HTTP responses using the fluent Response API, including JSON, status codes, headers, and more.</li> <li>File Import Utility: Securely import files with validation, metadata access, and content handling using the <code>import()</code> function and the <code>ImportedFile</code> object.</li> </ul> <p>Explore each page for full usage examples and best practices.</p>"},{"location":"references/file-import-utility/","title":"File Import Utility","text":""},{"location":"references/file-import-utility/#overview","title":"Overview","text":"<p>The file import utility provides a secure way to handle file imports with validation and returns a rich <code>ImportedFile</code> object.</p>"},{"location":"references/file-import-utility/#must-import-namespace","title":"Must Import Namespace","text":"<pre><code>&lt;?php\nuse function Component\\import;\nuse PhpSPA\\Exceptions\\AppException;\n</code></pre>"},{"location":"references/file-import-utility/#function-reference","title":"Function Reference","text":""},{"location":"references/file-import-utility/#import","title":"<code>import()</code>","text":"<pre><code>function import(string $file): ImportedFile\n</code></pre>"},{"location":"references/file-import-utility/#description","title":"Description","text":"<p>Imports a file with validation and returns an <code>ImportedFile</code> object.</p>"},{"location":"references/file-import-utility/#example","title":"Example","text":"<pre><code>&lt;?php\n\n   $image = import('assets/profile.jpg');\n\n   echo \"&lt;img src='{$image}'&gt;\";\n</code></pre>"},{"location":"references/file-import-utility/#metadata-methods","title":"Metadata Methods","text":"Method Returns Description <code>getContentType()</code> string File MIME type <code>getContentLength()</code> int Base64 content length <code>getOriginalSize()</code> int Original file size in bytes <code>getLocation()</code> string Original file path <code>getFilename()</code> string Filename without path <code>getExtension()</code> string File extension <code>isImage()</code> bool Whether file is an image"},{"location":"references/file-import-utility/#content-methods","title":"Content Methods","text":"Method Returns Description <code>getRawContent()</code> string Decoded file content <code>getBase64Content()</code> string Base64 encoded content <code>saveAs(string $dest)</code> bool Saves file to new location"},{"location":"references/file-import-utility/#usage-examples","title":"Usage Examples","text":""},{"location":"references/file-import-utility/#basic-file-import","title":"Basic File Import","text":"<pre><code>&lt;?php\nuse PhpSPA\\Exceptions\\AppException;\nuse function PhpSPA\\Component\\import;\n\ntry {\n    $file = import('documents/report.pdf');\n    echo 'File size: ' . $file-&gt;getOriginalSize() . ' bytes';\n} catch (AppException $e) {\n    error_log($e-&gt;getMessage());\n}\n</code></pre>"},{"location":"references/file-import-utility/#image-handling","title":"Image Handling","text":"<pre><code>&lt;?php\n$image = import('gallery/photo.jpg');\n\nif ($image-&gt;isImage()) {\n    echo '&lt;img src=\"' . $image . '\" \n         alt=\"' . htmlspecialchars($image-&gt;getFilename()) . '\"\n         class=\"img-fluid\"&gt;';\n}\n</code></pre>"},{"location":"references/file-import-utility/#file-saving","title":"File Saving","text":"<pre><code>&lt;?php\n$imported = import('temp/upload.tmp');\n\nif ($imported-&gt;saveAs('archive/' . $imported-&gt;getFilename())) {\n    echo 'File archived successfully';\n}\n</code></pre>"},{"location":"references/file-import-utility/#error-handling","title":"Error Handling","text":"<p>Common error scenarios:</p> <pre><code>&lt;?php\ntry {\n    // Attempt to import non-existent file\n    $file = import('missing.png');\n} catch (AppException $e) {\n    echo $e-&gt;getMessage(); // \"Unable to get file: missing.png\"\n}\n\ntry {\n    // Attempt to import large file\n    $file = import('large-video.mp4');\n} catch (AppException $e) {\n    echo $e-&gt;getMessage(); // \"File too large to import: large-video.mp4\"\n}\n</code></pre>"},{"location":"references/file-import-utility/#best-practices","title":"Best Practices","text":"<ol> <li>Always wrap imports in try-catch blocks</li> <li>Verify file types before processing</li> <li>Use <code>isImage()</code> for image-specific handling</li> <li>Store large files directly rather than using data URIs</li> </ol>"},{"location":"references/response/","title":"phpSPA v1.1.8 \u2014 Router &amp; Response","text":"<p>This document describes how to use the new Router and Response APIs introduced in v1.1.8. It contains full usage examples, API reference, and migration tips.</p>"},{"location":"references/response/#router-quick-examples","title":"Router \u2014 Quick examples","text":""},{"location":"references/response/#automatic-dispatch-recommended-for-web-apps","title":"Automatic dispatch (recommended for web apps)","text":"<p>Register routes normally; the router dispatches automatically when the PHP script ends.</p> <pre><code>&lt;?php\n\nuse PhpSPA\\Http\\Router;\nuse PhpSPA\\Http\\Response;\nuse PhpSPA\\Http\\Request;\n\n// Simple route\nRouter::get('/', function(Request $req) {\n    return Response::json(['message' =&gt; 'Hello world']);\n});\n\n// Parameterized route (MapRoute typed parameter support)\nRouter::get('/user/{id: int}', function(Request $req, int $id) {\n    // $id is validated and typed by MapRoute\n    return Response::json(['user_id' =&gt; $id]);\n});\n</code></pre>"},{"location":"references/response/#response-api-examples","title":"Response \u2014 API &amp; examples","text":"<p><code>PhpSPA\\Http\\Response</code> is designed for concise, fluent response construction.</p>"},{"location":"references/response/#create-responses","title":"Create responses","text":"<pre><code>&lt;?php\nuse PhpSPA\\Http\\Response;\n\n// Basic JSON response (static)\nreturn Response::json(['status' =&gt; 'OK']);\n\n// Fluent construction\nreturn (new Response())\n    -&gt;data(['result' =&gt; 'value'])\n    -&gt;status(200)\n    -&gt;header('X-Custom', 'value')\n    -&gt;contentType('application/json');\n\n// Convenience shortcut\nResponse::sendJson(['ok' =&gt; true]); // builds and sends immediately\n</code></pre>"},{"location":"references/response/#common-helper-methods","title":"Common helper methods","text":"<ul> <li><code>Response::json($data, $status = 200, $headers = [])</code> \u2014 create a JSON response.</li> <li><code>Response::make($data, $status = 200, $headers = [])</code> \u2014 create a Response instance.</li> <li><code>Response::sendJson(...)</code>, <code>Response::sendSuccess(...)</code>, <code>Response::sendError(...)</code> \u2014 build &amp; send shortcuts.</li> <li>Instance helpers: <code>data()</code>, <code>status()</code>, <code>header()</code>, <code>contentType()</code>, <code>success()</code>, <code>error()</code>.</li> </ul>"},{"location":"references/response/#using-the-global-response-helper","title":"Using the global <code>response()</code> helper","text":"<p>The repo provides a global helper function <code>response()</code> that returns a <code>Response</code> instance. Use it for fluent convenience in route callbacks.</p> <pre><code>&lt;?php\n// Example using response() function\nreturn response(['message' =&gt; 'ok'], 200)\n    -&gt;header('X-Hello', 'world')\n    -&gt;contentType('application/json');\n\n// Example using response() function for registering route\nresponse()-&gt;get('/example', function(Request $request) {\n    return response()-&gt;json(['example' =&gt; true]);\n});\n</code></pre>"},{"location":"references/response/#complete-example","title":"Complete example","text":"<pre><code>&lt;?php\nrequire_once 'path/to/vendor/autoload.php';\n\nuse PhpSPA\\Http\\Response;\nuse PhpSPA\\Http\\Request;\nuse function PhpSPA\\Http\\response;\n\n$request = new Request();\n$response = Response::fromRequest($request)-&gt;caseSensitive();\n\n// Define your routes\n$response-&gt;get('/user/{id: int}', function (Request $request, int $id) {\n    $user = 2; // example lookup\n    return response(['message' =&gt; 'Hello from route with ID: ' . $id, 'data' =&gt; $user], 200)\n        -&gt;header('X-Route-Header', 'route_value');\n});\n\n$response-&gt;get('/status', function (Request $request) {\n    return response()-&gt;json([\n        'status' =&gt; 'OK',\n        'message' =&gt; 'Server is running.'\n    ]);\n});\n\n$response-&gt;get('/data', function (Request $request) {\n    return response()\n        -&gt;json(['data' =&gt; 'some data'])\n        -&gt;header('X-Custom-Header', 'Value')\n        -&gt;contentType('application/json');\n});\n\n// Convenience methods\n$response-&gt;get('/success', function (Request $request) {\n    return response()-&gt;success(['result' =&gt; 'data'], 'Operation successful');\n});\n\n$response-&gt;get('/error', function (Request $request) {\n    return response()-&gt;error('Something went wrong', 500);\n});\n</code></pre>"},{"location":"references/response/#maproute-pattern-reference","title":"MapRoute pattern reference","text":"<p>MapRoute supports parameter patterns and strict types in route declarations. Examples:</p> <ul> <li><code>/user/{id}</code> \u2014 simple parameter</li> <li><code>/user/{id: int}</code> \u2014 typed parameter (int)</li> <li><code>/search/{q: string}</code> \u2014 string param</li> </ul> <p>For full details see https://phpspa.tech/en/stable/routing/advanced-routing.</p>"},{"location":"requests/","title":"Handling Requests &amp; Sessions","text":"<p>Your components often need to process incoming data, like form submissions or API calls. PhpSPA provides a clean, object-oriented way to access request data.</p> <p>Request Object</p> <p>When a component is rendered, it can receive the current <code>Request</code> object as an argument.</p>"},{"location":"requests/#accessing-request-data","title":"Accessing Request Data","text":"<p>The <code>Request</code> object is a powerful wrapper around PHP's superglobals (<code>$_POST</code>, <code>$_GET</code>, <code>$_FILES</code>, etc.), making your code cleaner and more secure.</p> <p>Here's how you would handle a form submission:</p> <pre><code>&lt;?php\n\nuse PhpSPA\\Component;\nuse PhpSPA\\Http\\Request;\n\n$loginPage = new Component(function (Request $request) {\n   // Check if the form was submitted\n   if ($request-&gt;isMethod('POST')) {\n      $email = $request('email');\n      $password = $request('password');\n\n      // ... process login logic ...\n   }\n\n   // Display the login form\n   echo &lt;&lt;&lt;HTML\n      &lt;form method=\"POST\"&gt;\n         &lt;input type=\"email\" name=\"email\" placeholder=\"Email\"&gt;\n         &lt;input type=\"password\" name=\"password\" placeholder=\"Password\"&gt;\n         &lt;button type=\"submit\"&gt;Log In&lt;/button&gt;\n      &lt;/form&gt;\n   HTML;\n});\n\n$loginPage-&gt;route('/login')-&gt;method('GET|POST');\n</code></pre> <p>Request Methods</p> <p>The <code>Request</code> object has many other useful methods:</p> <ul> <li><code>$request-&gt;get('key')</code>: Get a URL query parameter</li> <li><code>$request-&gt;json('key')</code>: Get data from a JSON request body</li> <li><code>$request-&gt;files('avatar')</code>: Access uploaded file data</li> <li><code>$request-&gt;header('Authorization')</code>: Read a request header</li> <li><code>$request-&gt;ip()</code>: Get the client's IP address</li> <li><code>$request-&gt;isAjax()</code>: Check if it's an AJAX request</li> </ul>"},{"location":"requests/#redirects-session-management","title":"Redirects &amp; Session Management","text":"<p><code>PhpSPA</code> also includes helpers for common actions.</p> RedirectingSessions <p>Use the global <code>Redirect()</code> function to send the user to a new page.</p> <pre><code>&lt;?php\n\nuse function PhpSPA\\Http\\Redirect;\n\nRedirect('/dashboard');\n</code></pre> <p>Use the static <code>Session</code> class to manage user data across requests.</p> <pre><code>&lt;?php\n\nuse PhpSPA\\Http\\Session;\n\nSession::set('user_id', 123);\n$userId = Session::get('user_id');\n</code></pre> <p>Login Handler</p> <pre><code>&lt;?php\n\nuse PhpSPA\\Http\\Request;\nuse PhpSPA\\Http\\Session;\nuse function PhpSPA\\Http\\Redirect;\n\nfunction handleLogin(Request $request) {\n   $email = $request-&gt;post('email');\n   // ... validate user ...\n\n   if ($isValid) {\n      Session::set('user_id', 123); // Log the user in\n      Redirect('/dashboard');      // Send them to the dashboard\n   }\n}\n</code></pre>"},{"location":"requests/#content-security-policy-csp","title":"Content Security Policy (CSP)","text":"<p>For added security, you can easily enable a nonce-based Content Security Policy to protect against XSS attacks.</p> <pre><code>&lt;?php\nuse PhpSPA\\Http\\Security\\Nonce;\n\n// Enable CSP with a strict policy\nNonce::enable();\n\n$nonce = Nonce::attr();\n\n// In your layout, use the nonce attribute for your scripts\necho &lt;&lt;&lt;HTML\n   &lt;script $nonce&gt;\n      /* ... */\n   &lt;/script&gt;\nHTML;\n</code></pre> <p>Security Best Practice</p> <p>The nonce attribute ensures only authorized inline scripts can execute, protecting against XSS attacks.</p>"},{"location":"requests/api-authentication/","title":"API Authentication","text":"<p>PhpSPA isn't just for rendering HTML. You can easily create secure API endpoints by creating components that return JSON. The <code>Request</code> object has built-in helpers to make checking for authentication credentials simple and clean.</p> <p>Secure APIs</p> <p>This is perfect for when your frontend needs to fetch data from a secure source.</p>"},{"location":"requests/api-authentication/#api-key-authentication","title":"API Key Authentication","text":"<p>A common method for securing an API is to require an API key in the request headers. The <code>$request-&gt;apiKey()</code> method makes this easy to check.</p> <p>By default, it looks for the key in the <code>Api-Key</code> header.</p> <pre><code>&lt;?php\nuse PhpSPA\\Component;\nuse PhpSPA\\Http\\Request;\n\n$userDataApi = new Component(function (Request $request) {\n   // 1. Validate the API key.\n   // Replace 'YOUR_SECRET_KEY' with your actual key.\n   if (!$request-&gt;apiKey('YOUR_SECRET_KEY')) {\n      http_response_code(401); // Unauthorized\n      header('Content-Type: application/json');\n      echo json_encode(['error' =&gt; 'Invalid API Key']);\n      return;\n   }\n\n   // 2. If the key is valid, return the data.\n   $data = ['id' =&gt; 123, 'name' =&gt; 'John Doe', 'email' =&gt; 'john.doe@example.com'];\n   header('Content-Type: application/json');\n   return json_encode($data);\n});\n\n$userDataApi-&gt;route('/api/user');\n</code></pre> <p>Default Header</p> <p>By default, it looks for the key in the <code>Api-Key</code> header.</p>"},{"location":"requests/api-authentication/#http-basic-bearer-token-authentication","title":"HTTP Basic &amp; Bearer Token Authentication","text":"<p>For more standard authentication methods, the <code>$request-&gt;auth()</code> method is your go-to tool. It automatically parses the <code>Authorization</code> header and gives you access to both Basic and Bearer token credentials.</p> <pre><code>&lt;?php\nuse PhpSPA\\Component;\nuse PhpSPA\\Http\\Request;\n\n$secureDataApi = new Component(function (Request $request) {\n   $auth = $request-&gt;auth();\n\n   // Check for a Bearer token (commonly used with JWTs)\n   if ($auth-&gt;bearer) {\n      // ... validate the Bearer token ...\n      if (isValidToken($auth-&gt;bearer)) {\n         echo json_encode(['data' =&gt; 'This is your secure data.']);\n         return;\n      }\n   }\n\n   // Check for Basic auth credentials\n   if ($auth-&gt;basic) {\n      // $auth-&gt;basic is an object with 'user' and 'password' properties\n      if ($auth-&gt;basic-&gt;user === 'admin' &amp;&amp; $auth-&gt;basic-&gt;password === 'secret') {\n         echo json_encode(['data' =&gt; 'Authenticated via Basic Auth.']);\n         return;\n      }\n   }\n\n   // If no valid auth is found, deny access.\n   http_response_code(401);\n   echo json_encode(['error' =&gt; 'Authentication required.']);\n});\n\n$secureDataApi-&gt;route('/api/secure-data');\n</code></pre> <p>Authentication Methods</p> <p>Support both Bearer tokens (commonly used with JWTs) and HTTP Basic authentication with a single method.</p>"},{"location":"requests/auto-reloading-components/","title":"Auto-Reloading Components \ud83d\udd04","text":"<p>For components that display live, frequently changing data\u2014like a news ticker, a dashboard chart, or a notification feed\u2014you can instruct PhpSPA to automatically refresh them at a set interval.</p> <p>Efficient Updates</p> <p>This is done by chaining the <code>-&gt;reload()</code> method to your component. This method is highly efficient, as it only re-fetches and updates the specific component, not the entire page.</p>"},{"location":"requests/auto-reloading-components/#how-to-use-it","title":"How to Use It","text":"<p>The <code>-&gt;reload()</code> method accepts one argument: the refresh interval in milliseconds.</p> <p>Here is an example of a live clock component that updates itself every second.</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\nuse PhpSPA\\Component;\n\n// Assume our app and layout are set up\n$app = new App($layout);\n\n// --- Live Clock Component ---\n$liveClock = new Component(function () {\n   // This PHP code runs on the server every time the component is fetched\n   $currentTime = date('H:i:s');\n   return \"&lt;h2&gt;Current Server Time: {$currentTime}&lt;/h2&gt;\";\n});\n\n// Configure the component to reload every 1000 milliseconds (1 second)\n$liveClock\n   -&gt;route('/clock')\n   -&gt;title('Live Clock')\n   -&gt;reload(1000);\n\n// Attach the component\n$app-&gt;attach($liveClock);\n\n$app-&gt;run();\n</code></pre> <p>Live Clock Example</p> <p>Here is an example of a live clock component that updates itself every second.</p> <p>Automatic Updates</p> <p>When a user visits the <code>/clock</code> page, PhpSPA's JavaScript runtime will see the reload instruction and automatically request a fresh version of the <code>liveClock</code> component every second, keeping the time perfectly up-to-date without any full page reloads.</p>"},{"location":"requests/client-side-events-and-api/","title":"Client-Side Events &amp; API","text":"<p>PhpSPA provides a powerful client-side API to hook into the navigation lifecycle and control the application's behavior directly from your JavaScript. This is essential for creating features like loading indicators, animations, and handling navigation errors.</p> <p>Event System</p> <p>Hook into navigation events to create loading indicators, animations, and error handling.</p>"},{"location":"requests/client-side-events-and-api/#listening-to-navigation-events","title":"Listening to Navigation Events","text":"<p>You can listen to navigation events using <code>phpspa.on()</code>. This is perfect for showing or hiding a loading spinner.</p> beforeloadload <p>This event fires before a new page request is made. It receives the destination <code>route</code> as an argument.</p> <pre><code>phpspa.on('beforeload', ({ route }) =&gt; {\n   console.log(`Navigating to: ${route}`);\n   // Show your loading spinner here\n   document.getElementById('loader').style.display = 'block';\n});\n</code></pre> <p>This event fires after a page request completes, whether it was successful or not.</p> <ul> <li>On Success: <code>{ route, success: true, error: false }</code></li> <li>On Failure: <code>{ route, success: false, error: 'Error message', data?: ... }</code></li> </ul> <pre><code>phpspa.on('load', ({ route, success, error, data }) =&gt; {\n   // Hide your loading spinner here\n   document.getElementById('loader').style.display = 'none';\n\n   if (!success) {\n      console.error(`Failed to load route: ${route}`, error);\n      // You could show an error message to the user here\n   }\n});\n</code></pre> <p>Loading States</p> <p>Combine <code>beforeload</code> and <code>load</code> events to create smooth loading transitions.</p>"},{"location":"requests/client-side-events-and-api/#client-side-api-functions","title":"Client-Side API Functions","text":"<p>The PhpSPA object also provides several utility functions to control your application.</p> <ul> <li> <p> Navigation Control</p> <p><code>phpspa.back()</code> &amp; <code>phpspa.forward()</code></p> <p>Navigate backward or forward in the browser's session history.</p> </li> <li> <p> Page Reload</p> <p><code>phpspa.reload()</code></p> <p>Performs a \"soft\" reload of the current page by re-fetching the component's content without a full browser refresh.</p> </li> <li> <p> Component Refresh</p> <p><code>phpspa.reloadComponent()</code></p> <p>A more granular reload that only refreshes the content of the currently active component. This is useful for live data updates.</p> </li> <li> <p> State Management</p> <p><code>phpspa.setState(key, value)</code></p> <p>The same as the global <code>setState()</code> function. It updates a state variable and returns a promise that resolves when the re-render is complete.</p> </li> </ul> <p>State Promise</p> <p>State Promise</p> <pre><code>setState('counter', 5).then(() =&gt; {\n   console.log('Counter has been updated and the component has re-rendered!');\n});\n</code></pre>"},{"location":"requests/request-object/","title":"The Request Object: In-Depth","text":"<p>The <code>Request</code> object is your primary tool for interacting with incoming data. Beyond the basic methods like <code>post()</code> and <code>get()</code>, it offers several powerful shortcuts and helpers to make your code more concise and readable.</p> <p>Universal Access</p> <p>The Request object provides unified access to all types of input data.</p>"},{"location":"requests/request-object/#universal-parameter-access","title":"Universal Parameter Access","text":"<p>Instead of checking <code>post()</code>, <code>get()</code>, and <code>json()</code> separately, you can use the <code>Request</code> object like a function to get a parameter from any input source (<code>$_REQUEST</code>). This is the quickest way to access data.</p> <pre><code>&lt;?php\nuse PhpSPA\\Http\\Request;\n\nfunction SearchHandler(Request $request) {\n   // This will get the 'term' value whether it comes from\n   // a GET query string (?term=...) or a POST form field.\n   $searchTerm = $request('term');\n\n   // ... perform search logic ...\n   return \"&lt;p&gt;Showing results for: &lt;strong&gt;{$searchTerm}&lt;/strong&gt;&lt;/p&gt;\";\n}\n</code></pre> <p>Flexible Input</p> <p>This will get the 'term' value whether it comes from a GET query string (?term=...) or a POST form field.</p>"},{"location":"requests/request-object/#handling-file-uploads","title":"Handling File Uploads","text":"<p>Accessing uploaded files is simple with the <code>-&gt;files()</code> method.</p> All FilesSpecific File <p>Calling <code>$request-&gt;files()</code> with no arguments returns an array of all uploaded files.</p> <pre><code>&lt;?php\n\n$allFiles = $request-&gt;files();\n</code></pre> <p>Calling it with a name returns the data for that specific file input.</p> <pre><code>&lt;?php\n\n$avatarFile = $request-&gt;files('avatar');\n</code></pre> <p>File Upload Handler</p> <pre><code>&lt;?php\n\nuse PhpSPA\\Http\\Request;\n\nfunction ProfileUpload(Request $request) {\n   if ($request-&gt;isMethod('POST')) {\n      $avatarFile = $request-&gt;files('avatar');\n\n      if ($avatarFile &amp;&amp; $avatarFile['error'] === UPLOAD_ERR_OK) {\n         // A file was successfully uploaded\n         $tmpName = $avatarFile['tmp_name'];\n         $fileName = basename($avatarFile['name']);\n         move_uploaded_file($tmpName, \"uploads/{$fileName}\");\n\n         return \"&lt;p&gt;File uploaded successfully!&lt;/p&gt;\";\n      }\n   }\n\n   return &lt;&lt;&lt;HTML\n      &lt;form method=\"POST\" enctype=\"multipart/form-data\"&gt;\n         &lt;input type=\"file\" name=\"avatar\"&gt;\n         &lt;button type=\"submit\"&gt;Upload&lt;/button&gt;\n      &lt;/form&gt;\n   HTML;\n}\n</code></pre> <p>Secure Upload</p> <p>Always validate file uploads on the server-side before processing them.</p>"},{"location":"routing/","title":"Defining Routes","text":"<p> Routing is how you tell PhpSPA which component to show for a specific URL. This is done with the <code>-&gt;route()</code> method. </p> <p>Route Assignment</p> <p>You create a component for each page of your site and assign it a unique URL path.</p>"},{"location":"routing/#example","title":"Example","text":"<p>Simple Website</p> <p>Let's create a simple website with a home page and an about page.</p> <pre><code>&lt;?php\n\nuse PhpSPA\\App;\nuse PhpSPA\\Component;\n\n// Assume our layout is loaded\n$layout = require __DIR__ . '/layout.php';\n$app = new App($layout);\n\n// --- Create the Home Page Component ---\n$homePage = new Component(function () {\n   echo '&lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;';\n});\n$homePage-&gt;route('/'); // Maps this component to the root URL\n\n// --- Create the About Page Component ---\n$aboutPage = new Component(function () {\n   echo '&lt;h1&gt;About Our Company&lt;/h1&gt;';\n});\n$aboutPage-&gt;route('/about'); // Maps this component to the /about URL\n\n// Attach both components to the app\n$app-&gt;attach($homePage);\n$app-&gt;attach($aboutPage);\n\n// The router will now render the correct component\n$app-&gt;run();\n</code></pre> <p>That's it</p> <p>When a user visits your site at <code>/about</code>, PhpSPA will automatically render the <code>$aboutPage</code> component.</p>"},{"location":"routing/advanced-routing/","title":"Advanced Routing","text":"<p> PhpSPA's router is more than just static paths. It provides a powerful set of features for handling dynamic URLs, multiple routes, and specific HTTP methods, giving you full control over how your application responds to requests. </p>"},{"location":"routing/advanced-routing/#handling-url-parameters","title":"Handling URL Parameters","text":"<p>Dynamic Segments</p> <p>To capture dynamic segments from a URL, like a user's ID, you can define parameters in your route using curly braces <code>{}</code>. These parameters are then passed to your component in a special <code>$path</code> array.</p> <pre><code>&lt;?php\nuse PhpSPA\\Component;\n\n$userProfile = new Component(function (array $path) {\n   // The 'id' from the URL is available in the $path array\n   $userId = $path['id'] ?? 'guest';\n\n   return &lt;&lt;&lt;HTML\n      &lt;h1&gt;User Profile&lt;/h1&gt;\n      &lt;p&gt;You are viewing the profile for User ID: &lt;strong&gt;{$userId}&lt;/strong&gt;&lt;/p&gt;\n   HTML;\n});\n\n// This route will match URLs like /user/123, /user/456, etc.\n$userProfile-&gt;route('/user/{id}');\n</code></pre>"},{"location":"routing/advanced-routing/#typed-parameters-and-constraints","title":"Typed Parameters and Constraints","text":"<p>Type Validation</p> <p>You can enforce specific data types and constraints directly in your route definition. This is great for validation and ensuring your component receives the correct type of data.</p> Integer TypeAlphanumericArray TypeRange ConstraintUnion TypesNested Types <pre><code>&lt;?php\n\n// Only match if 'id' is an integer\n$component-&gt;route('/post/{id: int}');\n</code></pre> <pre><code>&lt;?php\n\n// Match if 'username' is alphanumeric\n$component-&gt;route('/profile/{username: alnum}');\n</code></pre> <pre><code>&lt;?php\n\n// Match if 'tags' is an array of strings\n$component-&gt;route('/posts/{tags: array&lt;string&gt;}');\n</code></pre> <pre><code>&lt;?php\n\n// Match an integer between 2 and 5 (inclusive)\n$component-&gt;route('/rating/{value: int&lt;2,5&gt;}');\n</code></pre> <pre><code>&lt;?php\n\n// Match if 'username' is a string or an integer\n$component-&gt;route('/user/{username: string|int}');\n</code></pre> <pre><code>&lt;?php\n\n// Even complex nested types are supported\n$component-&gt;route('/user/{username: array&lt;array&lt;string&gt;&gt;}/post/{id: array&lt;int&lt;999,999&gt;, string&gt;}');\n</code></pre>"},{"location":"routing/advanced-routing/#multiple-routes-and-http-methods","title":"Multiple Routes and HTTP Methods","text":"<p>Flexible Routing</p> <p>You can assign multiple routes or HTTP methods to a single component.</p> <ul> <li> <p> Multiple Routes</p> <p>Pass an array of paths to the <code>-&gt;route()</code> method.</p> </li> <li> <p> HTTP Methods</p> <p>Pass a pipe-separated string to the <code>-&gt;method()</code> method.</p> </li> </ul> <pre><code>&lt;?php\n\n$dashboard = new Component(function () {\n   return '&lt;h1&gt;Welcome to your Dashboard!&lt;/h1&gt;';\n});\n\n// This component will render for both /home and /dashboard\n$dashboard-&gt;route(['/home', '/dashboard']);\n\n$contactForm = new Component(function (Request $request) {\n   if ($request-&gt;isMethod('POST')) {\n      // Handle form submission...\n      return '&lt;p&gt;Thank you for your message!&lt;/p&gt;';\n   }\n   // Show the form on GET request\n   return '&lt;form method=\"POST\"&gt;&lt;/form&gt;';\n});\n\n// This component responds to both GET and POST requests on the same URL\n$contactForm-&gt;route('/contact')-&gt;method('GET|POST');\n</code></pre>"},{"location":"routing/component-configuration/","title":"Component Configuration","text":"<p>PhpSPA provides several powerful methods to configure how your components behave. These methods can be chained directly onto your component instances to customize routing, rendering, titles, and more.</p> <p>Method Chaining</p> <p>All component configuration methods return the component instance, allowing you to chain multiple configurations together.</p>"},{"location":"routing/component-configuration/#setting-the-page-title","title":"Setting the Page Title","text":"<p>Use the <code>-&gt;title()</code> method to set a dynamic page title for a component. This updates the browser's title bar when the component is loaded.</p> <pre><code>&lt;?php\nuse PhpSPA\\Component;\n\n$homePage = new Component(function() {\n    return '&lt;h1&gt;Welcome Home!&lt;/h1&gt;';\n});\n\n$homePage\n    -&gt;route('/')\n    -&gt;title('Home - My App');\n</code></pre> <p>Dynamic Titles</p> <p>Each component can have its own unique title, making your SPA feel like a traditional multi-page application.</p>"},{"location":"routing/component-configuration/#specifying-http-methods","title":"Specifying HTTP Methods","text":"<p>By default, components accept both <code>GET</code> and <code>POST</code> requests. Use the <code>-&gt;method()</code> method to restrict which HTTP methods are allowed.</p> <pre><code>&lt;?php\nuse PhpSPA\\Component;\n\n// Only accept GET requests\n$viewPage = new Component(fn() =&gt; '&lt;div&gt;Read-only content&lt;/div&gt;');\n$viewPage\n    -&gt;route('/view')\n    -&gt;method('GET');\n\n// Only accept POST requests (for form submissions)\n$submitForm = new Component(function() {\n    return '&lt;div&gt;Form submitted!&lt;/div&gt;';\n});\n$submitForm\n    -&gt;route('/submit')\n    -&gt;method('POST');\n\n// Accept multiple methods\n$apiEndpoint = new Component(fn() =&gt; '&lt;div&gt;API Response&lt;/div&gt;');\n$apiEndpoint\n    -&gt;route('/api/data')\n    -&gt;method('GET|POST|PUT|DELETE');\n</code></pre> <p>Use Cases</p> <ul> <li>GET only: Read-only pages, documentation</li> <li>POST only: Form submissions, data creation</li> <li>Multiple methods: API endpoints, flexible handlers</li> </ul>"},{"location":"routing/component-configuration/#setting-the-target-render-element","title":"Setting the Target Render Element","text":"<p>Components can render into specific elements in your layout using the <code>-&gt;targetID()</code> method. This is useful for rendering different components in different areas of your page.</p> <pre><code>&lt;?php\nuse PhpSPA\\Component;\n\n// Render in the main content area\n$mainContent = new Component(fn() =&gt; '&lt;div&gt;Main Content&lt;/div&gt;');\n$mainContent\n    -&gt;route('/dashboard')\n    -&gt;targetID('main-content');\n\n// Render in a sidebar\n$sidebar = new Component(fn() =&gt; '&lt;div&gt;Sidebar Widget&lt;/div&gt;');\n$sidebar\n    -&gt;route('/sidebar')\n    -&gt;targetID('sidebar');\n</code></pre> <p>In your layout:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n    &lt;div id=\"main-content\"&gt;&lt;/div&gt;\n    &lt;aside id=\"sidebar\"&gt;&lt;/aside&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Default Target ID</p> <p>Set a default target ID for all components using <code>$app-&gt;defaultTargetID(\"app\")</code>. Individual components can override this with their own <code>-&gt;targetID()</code>.</p>"},{"location":"routing/component-configuration/#route-case-sensitivity","title":"Route Case Sensitivity","text":"<p>By default, routes are case-insensitive. You can control this behavior per component or globally.</p>"},{"location":"routing/component-configuration/#per-component-case-sensitivity","title":"Per-Component Case Sensitivity","text":"Case SensitiveCase Insensitive <p>Make a specific route case-sensitive:</p> <pre><code>&lt;?php\n$component = new Component(fn() =&gt; '&lt;div&gt;Content&lt;/div&gt;');\n$component\n    -&gt;route('/AboutUs')\n    -&gt;caseSensitive();\n\n// Only matches: /AboutUs\n// Does NOT match: /aboutus, /ABOUTUS\n</code></pre> <p>Explicitly make a route case-insensitive:</p> <pre><code>&lt;?php\n$component = new Component(fn() =&gt; '&lt;div&gt;Content&lt;/div&gt;');\n$component\n    -&gt;route('/contact')\n    -&gt;caseInsensitive();\n\n// Matches: /contact, /Contact, /CONTACT, /CoNtAcT\n</code></pre> <p>When to Use Case Sensitivity</p> <ul> <li>Case sensitive: API endpoints, specific resource identifiers</li> <li>Case insensitive (default): User-facing pages for better accessibility</li> </ul>"},{"location":"routing/component-configuration/#global-case-sensitivity","title":"Global Case Sensitivity","text":"<p>Make all routes case-sensitive by default:</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\n\n$app = new App($layout);\n\n// Make all routes case-sensitive by default\n$app-&gt;defaultToCaseSensitive();\n\n// Individual components can still override this\n$flexibleComponent = new Component(fn() =&gt; '&lt;div&gt;Flexible&lt;/div&gt;');\n$flexibleComponent\n    -&gt;route('/flexible')\n    -&gt;caseInsensitive(); // This one is still case-insensitive\n</code></pre> <p>Best Practice</p> <p>For consistency, set a global default and only override it for specific components that need different behavior.</p>"},{"location":"routing/component-configuration/#complete-configuration-example","title":"Complete Configuration Example","text":"<p>Here's an example using all configuration methods together:</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\nuse PhpSPA\\Component;\n\n$app = new App($layout);\n\n// Set global defaults\n$app-&gt;defaultTargetID('app');\n$app-&gt;defaultToCaseSensitive();\n\n// Configure a fully customized component\n$userProfile = new Component(function() {\n    return &lt;&lt;&lt;HTML\n        &lt;div class=\"profile\"&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;p&gt;Welcome to your profile page!&lt;/p&gt;\n        &lt;/div&gt;\n    HTML;\n});\n\n$userProfile\n    -&gt;route('/user/profile')\n    -&gt;title('My Profile - UserApp')\n    -&gt;method('GET|POST')\n    -&gt;targetID('main-content')\n    -&gt;caseInsensitive();\n\n$app-&gt;attach($userProfile);\n$app-&gt;run();\n</code></pre> <ul> <li> <p> title(string $title)</p> <p>Sets the page title shown in the browser tab</p> <p>Example: <code>-&gt;title('Dashboard')</code></p> </li> <li> <p> method(string $method)</p> <p>Specifies allowed HTTP methods</p> <p>Default: <code>'GET|POST'</code></p> </li> <li> <p> targetID(string $id)</p> <p>Sets which element the component renders into</p> <p>Example: <code>-&gt;targetID('app')</code></p> </li> <li> <p> caseSensitive()</p> <p>Makes the route case-sensitive</p> <p>Only exact case matches work</p> </li> <li> <p> caseInsensitive()</p> <p>Makes the route case-insensitive</p> <p>Default behavior for routes</p> </li> </ul>"},{"location":"security/content-security-policy/","title":"Security: Content Security Policy (CSP)","text":"<p>To protect your application from Cross-Site Scripting (XSS) attacks, PhpSPA includes a simple helper for implementing a nonce-based Content Security Policy. This ensures that only the inline scripts and styles you've authorized can be executed by the browser.</p> <p>XSS Protection</p> <p>CSP helps prevent malicious scripts from executing in your application.</p>"},{"location":"security/content-security-policy/#step-1-enable-csp","title":"Step 1: Enable CSP","text":"<p>In your application's entry point (e.g., <code>index.php</code>), call <code>Nonce::enable()</code> before any output is sent. This will automatically generate a unique, secure nonce for each request and send the appropriate CSP header.</p> <pre><code>&lt;?php\nuse PhpSPA\\Http\\Security\\Nonce;\nuse PhpSPA\\App;\n\n// Enable a strict CSP policy before creating your app\nNonce::enable();\n\n// You can also customize the allowed sources\nNonce::enable([\n   'script-src' =&gt; [\"https://cdn.jsdelivr.net\"], // By default, 'self' is allowed\n   'style-src'  =&gt; [\"https://fonts.googleapis.com\"], // By default, 'self' is allowed\n]);\n\n// Now, create your app as usual\n$app = new App($layout);\n// ...\n</code></pre> <p>Custom Sources</p> <p>You can also customize the allowed sources for scripts and styles.</p>"},{"location":"security/content-security-policy/#step-2-apply-the-nonce-to-your-tags","title":"Step 2: Apply the Nonce to Your Tags","text":"<p>Now, you must add the generated nonce attribute to every inline <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> tag in your application. The <code>Nonce::attr()</code> method generates the full HTML attribute string for you (e.g., <code>nonce=\"a1b2c3d4\"</code>).</p> <p>This is typically done in your main Layout file.</p> <pre><code>&lt;?php\nuse PhpSPA\\Http\\Security\\Nonce;\n\nfunction Layout() {\n   // Get the nonce attribute string\n   $nonce = Nonce::attr();\n\n   return &lt;&lt;&lt;HTML\n      &lt;!DOCTYPE html&gt;\n      &lt;html&gt;\n      &lt;head&gt;\n         &lt;title&gt;My Secure App&lt;/title&gt;\n\n         &lt;!-- Apply the nonce to the style tag --&gt;\n         &lt;style {$nonce}&gt;\n            body { font-family: sans-serif; }\n         &lt;/style&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n         &lt;div id=\"app\"&gt;&lt;/div&gt;\n\n         &lt;!-- Apply the nonce to the script tag --&gt;\n         &lt;script {$nonce}&gt;\n            console.log('This script is allowed to run!');\n         &lt;/script&gt;\n      &lt;/body&gt;\n      &lt;/html&gt;\n   HTML;\n}\n</code></pre> <p>Security Hardened</p> <p>By following these two steps, you significantly harden your application's security against injection attacks. \ud83d\udc4d</p> <ul> <li>Use <code>Nonce::nonce()</code> to get just the nonce value if you need it for other purposes</li> <li>Call <code>Nonce::disable()</code> to turn off CSP maybe for another new Application instance</li> </ul>"},{"location":"security/cors/","title":"Configuration: Handling CORS \ud83c\udf0d","text":"<p>If you intend for your PhpSPA application to be used as an API for a frontend hosted on a different domain, you'll need to configure Cross-Origin Resource Sharing (CORS).</p> <p>Simple CORS Configuration</p> <p>PhpSPA makes this incredibly simple with the <code>-&gt;cors()</code> method, which you can chain directly onto your <code>$app</code> instance.</p>"},{"location":"security/cors/#enabling-with-defaults","title":"Enabling with Defaults","text":"<p>To enable CORS with a secure and sensible set of default headers, simply call the <code>cors()</code> method with no arguments. This is often all you need.</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\n\n$app = new App($layout);\n\n// Enable CORS with default settings\n$app-&gt;cors();\n\n// ... attach components, etc.\n\n$app-&gt;run();\n</code></pre> <p>Quick Setup</p> <p>The default configuration is suitable for most use cases and includes secure CORS headers.</p>"},{"location":"security/cors/#customizing-cors-settings","title":"Customizing CORS Settings","text":"<p>For more specific control, you can pass an associative array to the <code>cors()</code> method to define exactly which origins, methods, and headers are allowed.</p> <pre><code>&lt;?php\nuse PhpSPA\\App;\n\n$app = new App($layout);\n\n// Enable CORS with custom settings\n$app-&gt;cors([\n    'allow_origins' =&gt; ['https://my-frontend-app.com', 'https://staging.my-app.com'],\n    'allow_methods' =&gt; ['GET', 'POST', 'PUT', 'DELETE'],\n    'allow_headers' =&gt; ['Authorization', 'Content-Type', 'X-Requested-With'],\n    'allow_credentials' =&gt; true,\n    'max_age' =&gt; 86400, // Cache preflight requests for 24 hours\n]);\n\n// ...\n\n$app-&gt;run();\n</code></pre> <p>Fine-Grained Control</p> <p>This gives you fine-grained control to securely manage how your PhpSPA backend interacts with other web applications.</p>"},{"location":"security/cors/#configuration-options","title":"Configuration Options","text":"<ul> <li> <p> allow_origins</p> <p>Array of allowed domain origins</p> <p>Example: <code>['https://example.com']</code></p> </li> <li> <p> allow_methods</p> <p>HTTP methods to allow</p> <p>Example: <code>['GET', 'POST', 'PUT']</code></p> </li> <li> <p> allow_headers</p> <p>Headers that can be used in requests</p> <p>Example: <code>['Authorization', 'Content-Type']</code></p> </li> <li> <p> allow_credentials</p> <p>Allow cookies and authentication</p> <p>Default: <code>false</code></p> </li> <li> <p> max_age</p> <p>Preflight cache duration in seconds</p> <p>Default: <code>3600</code> (1 hour)</p> </li> </ul>"},{"location":"security/csrf-protection/","title":"CSRF Protection","text":"<p>Cross-Site Request Forgery (CSRF) is a common web security vulnerability. PhpSPA provides a simple and powerful way to protect your forms from these attacks, ensuring that submitted data comes from your actual site and not a malicious one.</p> <p>Security Layer</p> <p>CSRF protection validates that form submissions originate from your site, not from external malicious sources.</p>"},{"location":"security/csrf-protection/#protecting-forms-with-the-csrf-component","title":"Protecting Forms with the <code>Csrf</code> Component","text":"<p>The easiest way to add CSRF protection is by using the built-in <code>&lt;Component.Csrf /&gt;</code> component inside your forms.</p> <p>You must give it a unique <code>name</code> prop for each form to prevent token conflicts.</p> <pre><code>&lt;?php\nfunction ContactForm() {\n   return &lt;&lt;&lt;HTML\n      &lt;form method=\"POST\" action=\"/contact\"&gt;\n\n         &lt;Component.Csrf name=\"contact-form\" /&gt;\n\n         &lt;input type=\"text\" name=\"name\" required&gt;\n         &lt;textarea name=\"message\" required&gt;&lt;/textarea&gt;\n         &lt;button type=\"submit\"&gt;Send Message&lt;/button&gt;\n      &lt;/form&gt;\n   HTML;\n}\n</code></pre> <p>Unique Names</p> <p>You must give it a unique <code>name</code> prop for each form to prevent token conflicts.</p>"},{"location":"security/csrf-protection/#verifying-the-token","title":"Verifying the Token","text":"<p>On the server-side, you instantiate the <code>Csrf</code> class with the same form name and call the <code>verify()</code> method.</p> <pre><code>&lt;?php\nuse PhpSPA\\Http\\Request;\nuse Component\\Csrf;\n\nfunction handleContactSubmission(Request $request) {\n   if ($request-&gt;isMethod('POST')) {\n\n      // 1. Create a Csrf instance with the matching name.\n      $csrf = new Csrf(\"contact-form\");\n\n      // 2. Verify the submitted token.\n      if (!$csrf-&gt;verify()) {\n         // Stop execution if the token is invalid or missing.\n         http_response_code(403);\n         die('Invalid CSRF token!');\n      }\n\n      // --- Token is valid, process the form data safely ---\n      $name = $request('name');\n      // ...\n   }\n}\n</code></pre> <p>Token Reusability</p> <p>By default, <code>verify()</code> consumes the token, so it can only be used once. To verify a token without expiring it, pass <code>false</code>:</p> <pre><code>&lt;?php\n\nif ($csrf-&gt;verify(false)) {\n   // Token is valid and reusable.\n}\n</code></pre>"}]}